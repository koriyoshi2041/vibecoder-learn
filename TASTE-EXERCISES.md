# 品味锻造：深度练习手册

> **目标受众**：零代码基础的 Vibe Coder
> **本手册是 CURRICULUM-EXTENDED.md 的深度补充**
> **覆盖领域**：架构设计、性能优化、运维意识、数据建模
> **练习总数**：28 个详细练习，每个 30-90 分钟
> **设计日期**：2026年2月

---

# 第一章：深度架构 (Architecture Deep Dive)

> 架构是关于"如何把大问题拆成小问题"的艺术。
> 你不需要写代码就能理解架构——你需要的是"画方框和箭头"的能力。

---

## 练习 A1：数据库蓝图师 (Database Schema Design)

**练习名称**：「数据蓝图」— 用 ER 图设计数据世界

**格式**：在纸上或白板工具（Excalidraw/draw.io）中画出实体关系图 (ERD)，定义表结构、字段、关系。

**时间**：60 分钟

### 你需要准备的工具

- 纸和笔，或 Excalidraw (https://excalidraw.com)
- 三种颜色的笔/标记（蓝色=实体，绿色=属性，红色=关系）

### 具体步骤

**第一步（10分钟）：阅读需求**

> 场景：你要设计一个"二手图书交换平台"。用户可以上架自己不要的书，浏览别人的书，发起交换请求。

功能需求：
- 用户注册登录，有个人资料
- 用户可以上架图书（书名、作者、ISBN、品相、照片、描述）
- 用户可以浏览所有可交换的图书
- 用户可以向书主发起交换请求（"我想用我的《X》换你的《Y》"）
- 交换有状态：待处理 → 已接受/已拒绝 → 已完成
- 用户可以对完成的交换评价

**第二步（20分钟）：画 ER 图**

按以下模板画出每个实体（表）：

```
┌──────────────────────┐
│       User           │
├──────────────────────┤
│ id (PK)              │  ← 主键，唯一标识
│ email                │
│ username             │
│ avatar_url           │
│ location             │
│ created_at           │
└──────────────────────┘
```

你需要画出的实体（至少）：
1. User（用户）
2. Book（图书）
3. SwapRequest（交换请求）
4. Review（评价）

每个实体之间用线连接，标注关系类型：
- `1 ──── N` 表示一对多（一个用户有多本书）
- `N ──── N` 表示多对多（通过中间表连接）

**第三步（15分钟）：自我检查**

回答以下问题：
1. 一个用户删号了，他的书怎么处理？他发起的交换怎么处理？
2. 同一本书能同时被多个人请求交换吗？如何处理冲突？
3. 一个用户能给自己的书发交换请求吗？（应该不能——如何防止？）
4. 交换完成后，书的归属如何变更？
5. 如果一本书被交换了，它的状态如何更新？

**第四步（15分钟）：AI 对比**

将你的设计描述给 AI：
```
"我为一个二手图书交换平台设计了以下数据库 schema：
[描述你的表和字段]

请评价这个设计：
1. 有没有遗漏的实体或字段？
2. 关系设计是否合理？
3. 有没有潜在的数据一致性问题？
4. 如果用户量达到 10 万，这个设计有什么瓶颈？"
```

### 评分标准（满分 20 分）

| 维度 | 优秀 (5分) | 合格 (3分) | 不足 (1分) |
|------|-----------|-----------|-----------|
| 实体识别 | 识别出所有核心实体+1-2个补充实体 | 识别出核心实体 | 遗漏关键实体 |
| 字段完整性 | 每个实体有 id、时间戳、状态字段 | 有基本字段但缺少时间戳或状态 | 字段过少或过多 |
| 关系正确性 | 所有关系类型标注正确，外键明确 | 大部分关系正确 | 关系混乱或缺失 |
| 边界考虑 | 考虑了删除、冲突、状态流转 | 考虑了部分边界情况 | 未考虑边界情况 |

### 你将学到

- 数据如何被结构化存储
- 实体之间的关系类型（一对一、一对多、多对多）
- 为什么"先设计数据，再写功能"是正确的顺序
- 边界情况如何影响数据设计

---

## 练习 A2：API 菜单设计师 (REST API Design Review)

**练习名称**：「API 菜单」— 设计服务之间的对话规则

**格式**：为给定场景设计 REST API 端点列表，包括 URL 路径、HTTP 方法、请求/响应格式。

**时间**：45 分钟

### 背景知识（5分钟快速回顾）

API 就像餐厅菜单：
- **URL 路径** = 菜品名称（`/users`、`/books`）
- **HTTP 方法** = 你要对菜品做什么：
  - `GET` = 看（读取数据）
  - `POST` = 点（创建数据）
  - `PUT/PATCH` = 改（更新数据）
  - `DELETE` = 退（删除数据）
- **请求体** = 你的具体要求（"不加辣"）
- **响应体** = 上来的菜（返回的数据）
- **状态码** = 服务结果（200=成功，404=没找到，500=厨房着火了）

### 具体步骤

**第一步（5分钟）：阅读场景**

> 场景：为"宠物寄养平台"设计 API。宠物主人可以发布寄养需求，寄养家庭可以接单。

核心功能：
- 宠物主人管理自己的宠物信息
- 发布寄养需求（日期范围、特殊要求）
- 寄养家庭注册、管理资料
- 寄养家庭浏览和接受寄养请求
- 双方互相评价

**第二步（20分钟）：设计 API 端点**

使用以下模板：

```
# 宠物管理
GET    /api/v1/pets              → 获取我的宠物列表
POST   /api/v1/pets              → 添加新宠物
GET    /api/v1/pets/:id          → 获取单个宠物详情
PATCH  /api/v1/pets/:id          → 更新宠物信息
DELETE /api/v1/pets/:id          → 删除宠物

# 寄养需求
POST   /api/v1/boarding-requests → 发布寄养需求
GET    /api/v1/boarding-requests → 获取寄养需求列表（支持筛选）
...你来继续...

# 寄养家庭
...你来设计...

# 评价
...你来设计...
```

为每个端点补充：
- 谁有权调用？（主人？寄养家庭？两者都可以？）
- 请求需要什么参数？
- 返回什么数据？
- 可能的错误是什么？

**第三步（10分钟）：自我审查**

检查你的设计：

```
命名一致性检查：
- [ ] URL 全部使用小写和短横线（kebab-case）？
- [ ] 资源名称使用复数（/pets 不是 /pet）？
- [ ] 动词放在 HTTP 方法里，不在 URL 里？
      正确：DELETE /api/v1/pets/:id
      错误：POST /api/v1/delete-pet/:id

版本管理检查：
- [ ] URL 中包含版本号（/api/v1/...）？

权限检查：
- [ ] 每个端点都明确了谁能调用？
- [ ] 用户只能操作自己的数据？

分页检查：
- [ ] 列表端点支持分页（?page=1&limit=20）？
- [ ] 有默认分页大小和最大限制？
```

**第四步（10分钟）：AI 挑战**

```
"以下是我为宠物寄养平台设计的 REST API：
[你的设计]

请作为 API 设计专家审查：
1. 命名是否一致和规范？
2. 有没有遗漏的端点？
3. 错误处理是否完善？
4. 是否存在安全隐患（未授权访问）？
5. 如果要加搜索功能（按地区、日期、宠物类型筛选），端点怎么设计？"
```

### 评分标准（满分 20 分）

| 维度 | 优秀 (5分) | 合格 (3分) | 不足 (1分) |
|------|-----------|-----------|-----------|
| 命名规范 | 全部 kebab-case，复数，无动词 URL | 大部分规范 | 命名混乱 |
| 端点完整性 | 覆盖所有 CRUD + 搜索 + 状态变更 | 覆盖基本 CRUD | 大量遗漏 |
| 权限设计 | 每个端点有明确的权限说明 | 部分端点有权限说明 | 无权限考虑 |
| 错误处理 | 定义了常见错误码和消息 | 部分有错误处理 | 未考虑错误 |

### 你将学到

- API 是"服务之间的契约"
- RESTful 设计的核心原则
- 为什么命名一致性如此重要
- 版本管理如何保护现有用户

---

## 练习 A3：缓存策略棋局 (Caching Strategy)

**练习名称**：「缓存棋局」— 什么该记住，什么该忘记

**格式**：为给定场景制定缓存策略——什么数据应该缓存、缓存多久、什么时候失效。

**时间**：45 分钟

### 背景知识（5分钟）

缓存 = 把常用的结果存在"速拨"里，不用每次都去查。

```
没有缓存：用户请求 → 数据库查询（慢）→ 返回结果
有缓存：  用户请求 → 缓存命中（快）→ 返回结果
          用户请求 → 缓存未命中 → 数据库查询 → 存入缓存 → 返回结果
```

缓存的两大难题：
1. **缓存什么？** 频繁读取、很少变化的数据
2. **什么时候失效？** 数据变了，缓存必须更新，否则用户看到旧数据

### 具体步骤

**第一步（10分钟）：分析场景**

> 场景：一个在线教育平台，有以下数据：

| 数据类型 | 读取频率 | 更新频率 | 示例 |
|---------|---------|---------|------|
| 课程列表 | 极高（每人每次访问） | 低（每天新增几门） | 首页推荐课程 |
| 课程详情 | 高（每次点击课程） | 低（偶尔修改描述） | 课程介绍页 |
| 用户个人学习进度 | 中（用户查看自己的） | 高（每看一个视频就更新） | "已学习 60%" |
| 视频评论 | 中 | 中（每小时几条新评论） | 视频下方评论区 |
| 实时在线人数 | 极高（显示在每个页面） | 极高（每秒变化） | "当前 1,234 人在线" |
| 用户登录 Session | 每个请求都要验证 | 低（登录/登出时） | JWT Token |
| 支付记录 | 低（用户偶尔查看） | 极低（只在购买时创建） | 购买历史 |

**第二步（20分钟）：制定缓存策略**

为每种数据填写以下表格：

```
┌────────────────────────────────────────────────────────┐
│ 数据类型：课程列表                                       │
├────────────────────────────────────────────────────────┤
│ 是否缓存：是 / 否                                       │
│ 缓存位置：浏览器 / CDN / 服务器内存 / Redis              │
│ 缓存时长：___ 秒/分钟/小时                               │
│ 失效策略：时间到期 / 数据变更时主动清除 / 两者结合          │
│ 缓存键设计：cache:courses:page:{page}:sort:{sort}       │
│ 风险：如果缓存了旧数据会怎样？严重程度？                    │
│ 理由：____                                              │
└────────────────────────────────────────────────────────┘
```

**第三步（10分钟）：棘手场景分析**

回答以下问题：

1. **缓存雪崩**：如果所有课程缓存同时到期，会发生什么？
   - 提示：所有请求同时打到数据库 → 数据库崩溃
   - 解法：给缓存时长加随机偏移（比如 3600 秒 + 随机 0-300 秒）

2. **缓存穿透**：如果有人反复请求一个不存在的课程 ID 怎么办？
   - 提示：每次都打到数据库，因为缓存里永远查不到
   - 解法：缓存"空结果"（记住"这个ID不存在"，缓存 60 秒）

3. **一致性问题**：老师更新了课程标题，但学生看到的还是旧标题，可以接受吗？
   - 如果缓存 5 分钟？→ 学生最多看到 5 分钟前的旧标题
   - 如果缓存 24 小时？→ 可能看到昨天的旧标题
   - 你觉得哪个时间合理？

**第四步（5分钟）：总结决策**

画一个简单的缓存层次图：

```
用户浏览器缓存（静态资源：图片、CSS、JS）
    ↓
CDN 缓存（公共页面：首页、课程列表页）
    ↓
Redis 缓存（动态数据：课程详情、热门评论）
    ↓
数据库（最终真相来源：用户数据、支付记录）
```

### 评分标准（满分 20 分）

| 维度 | 优秀 (5分) | 合格 (3分) | 不足 (1分) |
|------|-----------|-----------|-----------|
| 缓存选择合理性 | 正确识别该缓存/不该缓存的数据 | 大部分选择正确 | 全缓存或全不缓存 |
| 失效策略 | 每种数据有针对性的失效策略 | 统一使用时间过期 | 未考虑失效 |
| 风险意识 | 分析了雪崩/穿透/一致性问题 | 考虑了部分风险 | 未考虑风险 |
| 层次设计 | 有清晰的多层缓存架构 | 有基本的缓存分层 | 无分层概念 |

### 你将学到

- 缓存是"用空间换时间"的权衡
- 不是所有数据都应该缓存
- 缓存失效是计算机科学中最难的问题之一
- "最终一致性"在大多数场景下是可接受的

---

## 练习 A4：消息队列思维训练 (Queue/Async Processing)

**练习名称**：「异步厨房」— 不是所有事都需要立刻完成

**格式**：识别系统中哪些操作应该同步（立即完成），哪些应该异步（放入队列，稍后处理）。

**时间**：40 分钟

### 背景知识（5分钟）

想象一个繁忙的餐厅：
- **同步** = 客人点了一杯水，服务员立刻倒一杯端过来（简单，必须立即完成）
- **异步** = 客人点了一道复杂的菜，服务员把菜单送到后厨，先去服务其他客人，菜好了再端过来
- **队列** = 后厨的订单队列——按先来后到排队，厨师一道一道做

```
同步请求：
用户 → 服务器 → [等待处理完成] → 返回结果
（用户一直在等，如果处理要 30 秒，用户就等 30 秒）

异步请求：
用户 → 服务器 → 立即返回"已收到" → 用户可以干别的
                    ↓
               放入消息队列
                    ↓
            后台 Worker 慢慢处理
                    ↓
            处理完后通知用户（邮件/推送/WebSocket）
```

### 具体步骤

**第一步（15分钟）：分类练习**

> 场景：一个电商平台有以下操作，标记每个操作应该同步还是异步：

| 操作 | 同步/异步？ | 你的理由 |
|------|-----------|---------|
| 用户登录验证 | | |
| 下单后发确认邮件 | | |
| 查看商品详情 | | |
| 生成月度销售报告（需分析100万条数据） | | |
| 上传商品图片并生成缩略图 | | |
| 检查库存是否充足 | | |
| 支付扣款 | | |
| 更新搜索索引（用户发布新商品后） | | |
| 给新注册用户发欢迎邮件 | | |
| 计算推荐商品列表 | | |
| 用户修改收货地址 | | |
| 批量导入 1000 件商品数据 | | |

**参考答案**（先自己做完再看）：

| 操作 | 同步/异步 | 理由 |
|------|----------|------|
| 用户登录验证 | 同步 | 用户必须立刻知道能不能登录 |
| 下单后发确认邮件 | 异步 | 邮件晚 5 秒到达完全可以，不应该让用户等 |
| 查看商品详情 | 同步 | 用户在等着看页面 |
| 生成月度销售报告 | 异步 | 可能需要几分钟，不能让用户干等 |
| 上传商品图片并生成缩略图 | 混合 | 上传同步确认收到；缩略图生成异步 |
| 检查库存是否充足 | 同步 | 必须在下单前确认 |
| 支付扣款 | 同步 | 必须立刻知道支付是否成功 |
| 更新搜索索引 | 异步 | 搜索结果晚几秒更新不影响用户体验 |
| 发欢迎邮件 | 异步 | 邮件不需要实时 |
| 计算推荐商品 | 异步（预计算） | 提前计算好，用户访问时直接读取 |
| 修改收货地址 | 同步 | 简单操作，立刻完成 |
| 批量导入 1000 件商品 | 异步 | 大量数据处理，后台排队处理，完成后通知 |

**第二步（15分钟）：设计异步流程**

选择上面的"生成月度销售报告"，画出完整的异步处理流程：

```
你来画：

1. 用户点击"生成报告"按钮
2. 服务器做什么？（提示：创建一个任务记录，状态="排队中"）
3. 用户看到什么？（提示："报告正在生成中，完成后我们会通知你"）
4. 后台 Worker 做什么？（提示：从队列中取任务，处理数据，生成文件）
5. 处理完后怎么通知用户？（提示：更新任务状态，发通知/邮件）
6. 如果处理失败了怎么办？（提示：重试3次？通知用户失败？）
7. 如果用户在处理过程中又点了一次"生成报告"？（提示：检查是否已有进行中的任务）
```

**第三步（10分钟）：失败处理设计**

回答以下问题：
1. 如果队列中有 1000 个任务，Worker 挂了怎么办？
2. 如果一个任务处理到一半 Worker 崩溃了，任务丢了吗？
3. 如果同一个任务被两个 Worker 同时领取了怎么办？
4. 队列满了（积压太多任务）怎么办？

### 评分标准（满分 20 分）

| 维度 | 优秀 (5分) | 合格 (3分) | 不足 (1分) |
|------|-----------|-----------|-----------|
| 同步/异步判断 | 10/12 以上判断正确 | 8/12 以上正确 | 低于 6/12 |
| 流程完整性 | 包含正常流程+失败处理+重复请求处理 | 有正常流程+基本失败处理 | 只有正常流程 |
| 用户体验考虑 | 用户在每个阶段都知道发生了什么 | 部分阶段有反馈 | 用户不知道进度 |
| 失败处理 | 考虑了 Worker 崩溃、重复处理、积压 | 考虑了部分失败场景 | 未考虑失败 |

### 你将学到

- 不是所有操作都需要立刻完成
- 异步处理大幅提升用户体验和系统吞吐量
- 队列是解耦系统组件的关键工具
- 失败处理比正常流程更重要

---

## 练习 A5：单体 vs 微服务决策训练

**练习名称**：「拆还是不拆」— 架构决策模拟器

**格式**：给定不同规模和阶段的产品场景，判断应该用单体还是微服务，并给出理由。

**时间**：45 分钟

### 背景知识（5分钟）

```
单体 (Monolith) = 一栋大楼，所有部门在同一栋楼里
  优点：简单、部署容易、团队小时效率高
  缺点：一个部门着火，整栋楼疏散

微服务 (Microservices) = 一个园区，每个部门独立的楼
  优点：一栋楼着火不影响其他楼、可以独立扩建
  缺点：楼之间需要修路（网络通信）、管理多栋楼更复杂
```

### 具体步骤

**第一步（20分钟）：场景判断**

为每个场景选择架构，并写下理由：

**场景 1：大学生创业项目**
- 团队：2人（你和一个朋友）
- 产品：校园二手交易平台
- 用户：预计 500-2000 学生
- 阶段：MVP（最小可行产品），需要 2 周内上线
- 预算：$0（使用免费额度）

你的选择：________ 理由：________

**场景 2：快速增长的 SaaS**
- 团队：15 名开发者，分 3 个小组
- 产品：项目管理工具（类似 Linear）
- 用户：50,000 付费用户
- 阶段：已运行 2 年，功能越来越多，发布越来越慢
- 问题：一个团队改了代码，经常把另一个团队的功能搞坏

你的选择：________ 理由：________

**场景 3：金融科技公司**
- 团队：8 名开发者
- 产品：支付处理 + 贷款审批 + 风控系统
- 用户：10,000 商户
- 阶段：已运行 1 年
- 要求：支付系统必须 99.99% 可用，贷款审批可以偶尔慢一点

你的选择：________ 理由：________

**场景 4：个人副业项目**
- 团队：只有你
- 产品：AI 写作助手
- 用户：刚开始，还没有用户
- 阶段：验证想法
- 目标：快速验证市场是否有需求

你的选择：________ 理由：________

**场景 5：大型电商平台重构**
- 团队：60 名开发者，分 8 个小组
- 产品：类似淘宝的电商平台
- 用户：500 万月活
- 阶段：单体应用已运行 5 年，代码库 200 万行
- 问题：部署一次要 4 小时，任何改动都可能引发连锁 bug

你的选择：________ 理由：________

**第二步（15分钟）：决策框架**

总结一个你自己的决策框架，填写以下表格：

```
选择单体 的条件：
- [ ] 团队小于 ___ 人
- [ ] 产品处于 ___ 阶段
- [ ] 用户量少于 ___
- [ ] 需要在 ___ 内上线
- [ ] ________________（你的补充条件）

选择微服务 的条件：
- [ ] 团队大于 ___ 人
- [ ] 不同模块有不同的 ___ 需求（可用性/扩展性）
- [ ] 部署频率需要高于 ___
- [ ] ________________（你的补充条件）

永远不要用微服务的场景：
- ________________
- ________________
```

**第三步（10分钟）：AI 辩论**

```
"我总结了一个单体 vs 微服务的决策框架：
[你的框架]

请扮演两个角色辩论：
角色 A（单体支持者）：解释为什么大多数创业公司应该从单体开始
角色 B（微服务支持者）：解释什么时候必须转向微服务

最后给出一个平衡的结论。"
```

### 评分标准（满分 20 分）

| 维度 | 优秀 (5分) | 合格 (3分) | 不足 (1分) |
|------|-----------|-----------|-----------|
| 场景判断 | 5/5 场景判断正确 | 3-4/5 正确 | 少于 3/5 |
| 理由质量 | 结合团队规模、阶段、需求给出具体理由 | 有基本理由 | "感觉应该"这类模糊理由 |
| 框架实用性 | 框架有明确的阈值和条件 | 框架方向正确但模糊 | 无框架或过于简单 |
| 避坑意识 | 意识到"过早微服务"是常见错误 | 有一定意识 | 认为微服务总是更好 |

### 你将学到

- 几乎所有创业项目都应该从单体开始
- 微服务是解决组织问题（团队协作）多于技术问题
- "先单体，再拆分"比"一开始就微服务"风险低得多
- 架构决策取决于上下文，没有"最佳"架构

---

## 练习 A6：状态机设计训练

**练习名称**：「状态流转图」— 事物如何从一个状态变成另一个

**格式**：为给定的业务流程绘制状态机图——明确每个状态、触发条件、不允许的流转。

**时间**：45 分钟

### 背景知识（3分钟）

状态机 = 事物在不同"状态"之间的转换规则

日常例子——交通灯：
```
红灯 ──(30秒)──→ 绿灯 ──(25秒)──→ 黄灯 ──(5秒)──→ 红灯
  ↑                                                   │
  └───────────────────────────────────────────────────┘
```
规则：绿灯不能直接变红灯（必须先变黄），红灯不能变黄灯。

### 具体步骤

**第一步（15分钟）：绘制订单状态机**

> 场景：电商平台的订单生命周期

画出所有可能的状态和转换：

```
起始状态：待支付 (Pending Payment)

你需要画出以下状态之间的所有合法转换：
- 待支付 (Pending Payment)
- 已支付 (Paid)
- 备货中 (Preparing)
- 已发货 (Shipped)
- 运输中 (In Transit)
- 已签收 (Delivered)
- 已完成 (Completed)
- 退款中 (Refunding)
- 已退款 (Refunded)
- 已取消 (Cancelled)
- 争议中 (Disputed)

对每个转换，标注：
- 触发条件（谁触发的？用户？系统？商家？）
- 是否可逆？
```

模板：
```
[待支付] ──用户支付──→ [已支付]
[待支付] ──超时30分钟──→ [已取消]
[待支付] ──用户主动取消──→ [已取消]
[已支付] ──商家确认──→ [备货中]
...你来继续...
```

**第二步（15分钟）：标注非法转换**

列出所有"不应该发生"的转换，并解释为什么：

```
非法转换列表：
- [ ] 已完成 → 待支付 （理由：不能从终态回到初态）
- [ ] 已取消 → 已支付 （理由：取消后不能再变成已支付）
- [ ] 已签收 → 已发货 （理由：时间不能倒流）
- [ ] _____ → _____ （理由：________）
- 你至少再列出 5 个
```

**第三步（10分钟）：极端情况分析**

回答以下问题：
1. 用户在"备货中"状态申请取消，商家已经打包了，怎么处理？
2. 包裹显示"已签收"但用户说没收到，进入什么状态？
3. 退款过程中，用户突然又收到了包裹，怎么处理？
4. 系统如何防止一个订单同时处于两个状态？（提示：数据库中每个订单只有一个 status 字段）

**第四步（5分钟）：代码视角检查**

告诉 AI：
```
"我设计了以下订单状态机：
[你的状态和转换列表]

请检查：
1. 有没有"死胡同"状态（进入后出不来）？
2. 有没有遗漏的状态或转换？
3. 如果用并发请求同时触发两个转换，会有什么问题？
4. 帮我生成一个状态转换的验证函数伪代码。"
```

### 评分标准（满分 20 分）

| 维度 | 优秀 (5分) | 合格 (3分) | 不足 (1分) |
|------|-----------|-----------|-----------|
| 状态完整性 | 包含所有正常+异常状态 | 包含正常状态 | 遗漏关键状态 |
| 转换正确性 | 所有转换都有触发条件和方向 | 大部分转换正确 | 转换混乱 |
| 非法转换识别 | 识别出 8+ 个非法转换 | 识别出 5+ 个 | 少于 3 个 |
| 极端情况处理 | 每个极端情况都有解决方案 | 部分有方案 | 未考虑 |

### 你将学到

- 复杂业务逻辑可以用状态机清晰表达
- "不允许的操作"和"允许的操作"同等重要
- 状态机帮你发现边界情况和业务规则冲突
- 先画状态机，再让 AI 实现——AI 产出的代码质量会好很多

---

## 练习 A7：速率限制设计

**练习名称**：「流量闸门」— 如何保护系统不被压垮

**格式**：为不同类型的 API 端点设计合理的速率限制策略。

**时间**：40 分钟

### 背景知识（5分钟）

速率限制 = 限制每个用户/IP 在一段时间内能发多少请求

类比：自助餐厅每人限取一盘寿司，防止一个人把所有寿司拿光。

```
常见策略：
- 固定窗口：每分钟最多 60 次请求
- 滑动窗口：任意 60 秒内最多 60 次请求
- 令牌桶：桶里有 60 个令牌，每次请求消耗一个，每秒补充一个
```

### 具体步骤

**第一步（15分钟）：设计限制规则**

> 场景：你的 SaaS 应用有以下端点，为每个设计速率限制：

| 端点 | 你设计的限制 | 理由 |
|------|------------|------|
| POST /api/login（登录） | 每 IP 每 15 分钟最多 ___ 次 | 防止暴力破解密码 |
| GET /api/products（产品列表） | 每用户每分钟最多 ___ 次 | |
| POST /api/orders（下单） | 每用户每分钟最多 ___ 次 | |
| POST /api/upload（文件上传） | 每用户每小时最多 ___ 次 | |
| POST /api/ai/generate（AI 生成） | 每用户每天最多 ___ 次 | |
| POST /api/password-reset（密码重置） | 每邮箱每小时最多 ___ 次 | |
| GET /api/search（搜索） | 每用户每分钟最多 ___ 次 | |
| POST /api/feedback（反馈） | 每用户每天最多 ___ 次 | |

**第二步（10分钟）：分层策略**

设计三层速率限制（免费用户 vs 付费用户 vs API 合作伙伴）：

```
免费用户：
- AI 生成：每天 ___ 次
- 文件上传：每天 ___ 次，每文件最大 ___ MB
- API 总调用：每小时 ___ 次

付费用户（$10/月）：
- AI 生成：每天 ___ 次
- 文件上传：每天 ___ 次，每文件最大 ___ MB
- API 总调用：每小时 ___ 次

API 合作伙伴（$100/月）：
- AI 生成：每天 ___ 次
- 文件上传：每天 ___ 次，每文件最大 ___ MB
- API 总调用：每小时 ___ 次
```

**第三步（10分钟）：用户体验设计**

当用户触发限制时，应该：

```
1. 返回什么 HTTP 状态码？（提示：429 Too Many Requests）

2. 返回什么信息？
   差的做法："请求过多"
   好的做法：____（提示：应该包含什么时候可以重试）

3. 响应头应该包含什么？
   X-RateLimit-Limit: ___（总限额）
   X-RateLimit-Remaining: ___（剩余次数）
   X-RateLimit-Reset: ___（重置时间）

4. 前端应该如何处理？
   - 在用户快要达到限额时 ____
   - 达到限额后 ____
   - 限额重置后 ____
```

**第四步（5分钟）：攻击防御**

思考以下攻击场景：
1. 攻击者用 1000 个不同 IP 地址注册 1000 个免费账号，每个账号都发满限额——你怎么防？
2. 攻击者在限制窗口即将重置的瞬间发大量请求——你怎么防？
3. 攻击者发现你的 AI 端点没有限制输入长度，发送超长文本消耗你的 API 费用——你怎么防？

### 评分标准（满分 20 分）

| 维度 | 优秀 (5分) | 合格 (3分) | 不足 (1分) |
|------|-----------|-----------|-----------|
| 限制合理性 | 限制值考虑了真实使用模式 | 有限制但值不够合理 | 过松或过紧 |
| 分层设计 | 免费/付费有合理梯度 | 有分层但梯度不清 | 无分层 |
| 用户体验 | 有清晰的提示、重试指引 | 有基本提示 | "请求过多"一句话 |
| 攻击防御 | 考虑了分布式攻击和边界攻击 | 考虑了基本攻击 | 未考虑攻击 |

### 你将学到

- 速率限制保护系统稳定性和成本可控性
- 好的限制对正常用户透明，只拦截滥用者
- 不同端点需要不同的限制策略
- 用户被限制时的体验也是产品设计的一部分

---

## 练习 A8：幂等性思维训练

**练习名称**：「只收一次钱」— 重复操作不应该重复生效

**格式**：识别哪些操作必须是幂等的，设计保证幂等性的方案。

**时间**：35 分钟

### 背景知识（3分钟）

幂等 = 做一次和做多次，结果完全一样。

日常例子：
- 幂等：按电梯的"关门"按钮——按1次和按10次效果一样
- 非幂等：在咖啡里加糖——加1次和加10次完全不同

在软件中：
- 幂等：`GET /user/123`（读取用户信息，读100次结果一样）
- 非幂等：`POST /transfer`（转账，执行两次就转了两倍的钱）

### 具体步骤

**第一步（10分钟）：识别练习**

标记以下操作是否幂等，如果不是，会造成什么后果：

| 操作 | 幂等？ | 如果执行两次的后果 |
|------|-------|-----------------|
| 查看账户余额 | | |
| 扣款 $100 | | |
| 把用户名设为 "张三" | | |
| 发送欢迎邮件 | | |
| 删除用户（软删除：标记为 deleted） | | |
| 删除用户（硬删除：从数据库移除） | | |
| 下单（创建新订单） | | |
| 更新订单状态为"已发货" | | |
| 增加商品库存 +10 | | |
| 设置商品库存为 50 | | |
| 点赞一条帖子 | | |
| 记录用户访问日志 | | |

**第二步（15分钟）：设计幂等方案**

> 场景：支付回调（Webhook）

支付平台（如 Stripe）在用户付款成功后会调用你的回调 URL 通知你。但网络不可靠，Stripe 可能会发送同一个通知2-3次。

设计一个方案，确保即使收到3次相同的支付通知，也只给用户增加一次余额。

```
提示——幂等键方案：

1. 每个支付通知都带一个唯一的 event_id
2. 你的系统维护一个"已处理事件"表
3. 收到通知时的流程：
   a. 检查 event_id 是否在"已处理事件"表中
   b. 如果在 → ____（怎么做？）
   c. 如果不在 → ____（怎么做？）
   d. 处理完后 → ____（怎么做？）

4. 极端情况：如果在步骤 c 和步骤 d 之间系统崩溃了怎么办？
   → ____（提示：数据库事务）
```

**第三步（10分钟）：前端幂等设计**

用户在提交表单时连点了两下"提交"按钮，如何防止创建两个订单？

列出至少 3 种方案：
```
方案 1（前端）：____
方案 2（前端）：____
方案 3（后端）：____

哪个方案最可靠？为什么？
```

### 评分标准（满分 20 分）

| 维度 | 优秀 (5分) | 合格 (3分) | 不足 (1分) |
|------|-----------|-----------|-----------|
| 识别准确性 | 10/12 以上正确识别 | 8/12 以上正确 | 低于 6/12 |
| 方案设计 | 包含幂等键+事务+去重 | 有基本去重方案 | 无方案 |
| 极端情况 | 考虑了崩溃恢复和并发 | 考虑了部分情况 | 未考虑 |
| 前后端结合 | 前后端都有防重设计 | 只有一端有 | 无防重设计 |

### 你将学到

- 在网络不可靠的世界里，任何操作都可能被重复执行
- "设置为"比"增加/减少"天然更幂等
- 幂等键（Idempotency Key）是解决重复请求的标准方案
- 前端防重是"锦上添花"，后端防重是"必须"

---

## 练习 A9：依赖关系分析

**练习名称**：「多米诺骨牌」— 一个服务倒了，谁会跟着倒

**格式**：分析系统中服务之间的依赖关系，识别单点故障和故障传播路径。

**时间**：40 分钟

### 具体步骤

**第一步（15分钟）：画依赖图**

> 场景：一个在线外卖系统有以下服务：

- 用户服务（管理用户账号）
- 商家服务（管理餐厅和菜单）
- 订单服务（处理下单和状态管理）
- 支付服务（处理付款和退款）
- 配送服务（匹配骑手、追踪位置）
- 通知服务（发送短信、推送、邮件）
- 搜索服务（搜索餐厅和菜品）
- 评价服务（管理评分和评论）
- 外部依赖：支付网关（支付宝/微信支付）、短信网关、地图 API

画出这些服务之间的依赖关系（谁调用谁）：

```
用户下单的调用链：
用户 → 订单服务 → 支付服务 → 支付网关
                → 商家服务（确认菜品可用）
                → 配送服务（分配骑手）
                → 通知服务（通知商家和骑手）
```

**第二步（15分钟）：故障影响分析**

填写以下表格——如果某个服务挂了，会影响什么：

| 挂掉的服务 | 直接影响 | 间接影响 | 严重程度 (1-5) | 可接受的恢复时间 |
|-----------|---------|---------|--------------|---------------|
| 支付服务 | 无法下单付款 | 新订单完全停止 | 5 | 5 分钟内 |
| 通知服务 | | | | |
| 搜索服务 | | | | |
| 评价服务 | | | | |
| 配送服务 | | | | |
| 支付网关（外部） | | | | |
| 地图 API（外部） | | | | |

**第三步（10分钟）：设计降级方案**

对于每个严重程度 >= 3 的故障，设计降级方案：

```
降级方案模板：

服务：____
故障场景：____
降级策略：
  - 是否有备用服务？
  - 能否用缓存数据顶替？
  - 能否关闭非核心功能保住核心功能？
  - 用户看到什么提示？
```

例如：
```
服务：搜索服务挂了
降级策略：
  - 退回到数据库直接查询（速度慢但能用）
  - 首页展示预缓存的热门餐厅列表
  - 用户提示："搜索功能暂时不可用，请浏览推荐餐厅"
```

### 评分标准（满分 20 分）

| 维度 | 优秀 (5分) | 合格 (3分) | 不足 (1分) |
|------|-----------|-----------|-----------|
| 依赖图完整性 | 包含直接+间接依赖+外部依赖 | 包含直接依赖 | 依赖关系混乱 |
| 影响分析准确性 | 区分直接和间接影响 | 有基本影响分析 | 未分析影响 |
| 严重程度判断 | 与业务影响一致 | 大部分合理 | 判断不准确 |
| 降级方案 | 每个高严重度故障有具体降级方案 | 有部分降级方案 | 无降级方案 |

### 你将学到

- 系统中的依赖关系形成"故障传播链"
- 外部依赖是最不可控的风险点
- 降级方案（graceful degradation）让系统在部分故障时仍可用
- 并非所有服务都同等重要——核心链路必须最可靠

---

# 第二章：性能优化 (Performance & Optimization)

> 性能不是"让程序员加班"能解决的问题。
> 它是关于"理解瓶颈在哪里"的直觉。
> 你不需要写代码就能发现性能问题——你需要的是"知道该看哪里"。

---

## 练习 B1：Core Web Vitals 体检员

**练习名称**：「网站体检」— 用 Google 的标准诊断你的网站

**格式**：使用 PageSpeed Insights 分析真实网站，解读每个指标的含义，制定优化方案。

**时间**：60 分钟

### 背景知识（5分钟）

Google 用三个核心指标衡量网站体验：

```
LCP (Largest Contentful Paint) — 最大内容绘制
  "页面的主要内容多久才出现？"
  好：< 2.5秒 | 一般：2.5-4秒 | 差：> 4秒
  类比：走进餐厅，多久才看到菜单

INP (Interaction to Next Paint) — 交互到下一次绘制
  "点了按钮后多久才有反应？"（取代了旧的 FID）
  好：< 200ms | 一般：200-500ms | 差：> 500ms
  类比：按了电梯按钮，多久灯才亮

CLS (Cumulative Layout Shift) — 累计布局偏移
  "页面内容有没有乱跳？"
  好：< 0.1 | 一般：0.1-0.25 | 差：> 0.25
  类比：你在读书，突然有人把你的书抽走换了一本
```

### 具体步骤

**第一步（10分钟）：测量 5 个网站**

打开 https://pagespeed.web.dev，分别测试以下网站（或替换为你常用的网站）：

| 网站 | 移动端 LCP | 移动端 INP | 移动端 CLS | 总分 |
|------|-----------|-----------|-----------|------|
| 你自己的项目网站 | | | | |
| https://apple.com | | | | |
| 一个你觉得"快"的网站 | | | | |
| 一个你觉得"慢"的网站 | | | | |
| 一个竞品网站 | | | | |

**第二步（15分钟）：分析你自己的网站**

在 PageSpeed Insights 的结果中，找到以下信息并记录：

```
诊断报告：

1. LCP 元素是什么？
   □ 一张大图片
   □ 一段文字
   □ 一个视频
   □ 其他：____

   LCP 慢的原因可能是：
   □ 图片太大（几 MB？）
   □ 服务器响应慢
   □ CSS/JS 阻塞了渲染
   □ 字体加载太慢

2. CLS 问题在哪里？
   □ 图片没有设置宽高（加载后撑开布局）
   □ 广告/弹窗插入导致内容下移
   □ 字体切换导致文字大小变化
   □ 动态内容加载后推挤其他内容

3. INP 问题在哪里？
   □ JavaScript 执行时间过长
   □ 主线程被阻塞
   □ 事件处理器太重
```

**第三步（20分钟）：制定优化方案**

对你的网站（或分数最低的网站），写一个优化计划：

```
优化计划模板：

网站：____
当前分数：移动端 ___/100，桌面端 ___/100
目标分数：移动端 ___/100，桌面端 ___/100

优先级 1（影响最大，最容易做）：
- 问题：____
- 解决方案：____
- 预期改善：____

优先级 2：
- 问题：____
- 解决方案：____
- 预期改善：____

优先级 3：
- 问题：____
- 解决方案：____
- 预期改善：____
```

**第四步（10分钟）：向 AI 提交优化请求**

```
"我的网站 PageSpeed Insights 分数如下：
移动端：___/100
LCP：___ 秒（问题元素：____）
INP：___ 毫秒
CLS：___

主要问题：
1. ____
2. ____
3. ____

请给我一个按优先级排序的优化清单，
每个优化说明：做什么、为什么有效、预期改善多少分。
只给我不需要改代码的优化（配置层面的）。"
```

### 评分标准（满分 20 分）

| 维度 | 优秀 (5分) | 合格 (3分) | 不足 (1分) |
|------|-----------|-----------|-----------|
| 指标理解 | 能用自己的话解释 LCP/INP/CLS | 知道指标名称和好坏阈值 | 不理解指标含义 |
| 诊断能力 | 能从报告中定位具体问题元素 | 知道有问题但不确定在哪 | 看不懂报告 |
| 方案针对性 | 每个问题有对应的具体解决方案 | 有泛泛的优化建议 | 无方案或方案与问题不匹配 |
| 优先级判断 | 按影响大小和难易程度正确排序 | 有优先级但排序不合理 | 无优先级 |

### 你将学到

- 性能不是"感觉快慢"，而是有精确的衡量标准
- 移动端性能通常远差于桌面端
- 大部分性能问题集中在图片和 JavaScript 上
- 优化是"投入产出比"的选择——先做影响最大、成本最低的

---

## 练习 B2：图片优化侦探

**练习名称**：「图片瘦身」— 让图片变小但看不出区别

**格式**：分析网站中的图片资源，制定优化策略。

**时间**：40 分钟

### 具体步骤

**第一步（10分钟）：审计图片资源**

打开你的网站（或任何网站），在浏览器中按 F12 打开开发者工具 → Network 标签 → 筛选 "Img"：

记录以下信息：

| 图片 | 原始大小 | 显示尺寸 | 格式 | 问题 |
|------|---------|---------|------|------|
| hero-image.jpg | 2.4 MB | 1200x600 px | JPEG | 原始尺寸 4000x2000，远大于显示尺寸 |
| logo.png | 340 KB | 120x40 px | PNG | 应该用 SVG |
| avatar1.jpg | 890 KB | 48x48 px | JPEG | 48px 的头像不需要 890KB |
| ... | | | | |

**第二步（15分钟）：制定优化策略**

为每张图片选择优化策略：

```
图片优化决策树：

这张图片是图标/Logo 吗？
  └─ 是 → 用 SVG 格式（矢量，无限缩放不模糊，通常很小）
  └─ 否 → 继续

这张图片有透明背景吗？
  └─ 是 → 用 WebP 格式（比 PNG 小 26%）
  └─ 否 → 继续

这张图片是照片吗？
  └─ 是 → 用 WebP 格式（比 JPEG 小 25-35%）
  └─ 否 → 用 WebP 或 AVIF

图片的显示尺寸是多少？
  └─ 生成对应尺寸的图片，不要用 4000px 的原图显示 400px
  └─ 为不同屏幕生成多个尺寸（srcset）

图片在首屏吗？
  └─ 是 → 优先加载（preload）
  └─ 否 → 懒加载（loading="lazy"）
```

**第三步（10分钟）：计算节省空间**

假设你的网站有以下图片，计算优化后节省多少：

| 图片 | 优化前 | 优化策略 | 预估优化后 | 节省 |
|------|-------|---------|----------|------|
| Hero 大图 | 2.4 MB | WebP + 调整尺寸到 1200px | ~180 KB | ~92% |
| 6 个产品图 | 6 x 800 KB = 4.8 MB | WebP + 适当尺寸 | 6 x 120 KB = 720 KB | ~85% |
| 20 个头像 | 20 x 500 KB = 10 MB | WebP + 调整到 96px | 20 x 8 KB = 160 KB | ~98% |
| Logo | 340 KB | SVG | ~5 KB | ~99% |
| **总计** | **17.5 MB** | | **~1.1 MB** | **~94%** |

**第四步（5分钟）：创建优化提示**

```
"请帮我优化项目中的图片资源：
1. 所有 JPEG/PNG 转换为 WebP 格式，提供 JPEG 后备
2. 使用 Next.js Image 组件实现自动尺寸适配和懒加载
3. 为 Hero 大图添加 preload
4. 所有装饰性图标替换为 SVG
5. 设置合理的图片质量：照片 80%，图标 90%

请列出需要修改的文件和具体改动。"
```

### 评分标准（满分 20 分）

| 维度 | 优秀 (5分) | 合格 (3分) | 不足 (1分) |
|------|-----------|-----------|-----------|
| 审计完整性 | 识别出所有可优化的图片 | 识别出大部分 | 只发现最明显的 |
| 策略正确性 | 格式选择和尺寸调整都合理 | 大部分策略正确 | 策略不当 |
| 节省计算 | 有具体数字和百分比 | 有估算 | 无数据支撑 |
| 实操能力 | 能写出具体的 AI 优化提示 | 知道要优化但不知道怎么让 AI 做 | 无法形成可执行方案 |

### 你将学到

- 图片通常占网页总大小的 50-80%
- 格式选择（WebP/AVIF/SVG）能带来巨大收益
- "不要用大图显示小区域"是最简单也最有效的优化
- 懒加载让用户只下载看到的图片

---

## 练习 B3：N+1 问题直觉训练

**练习名称**：「一百次还是一次」— 数据库查询的效率直觉

**格式**：通过类比和场景理解 N+1 查询问题，学会识别和避免它。

**时间**：35 分钟

### 背景知识（5分钟）

N+1 问题 = 本该一次搞定的事，却分成了 N+1 次。

```
类比：你是老师，要收全班 30 个学生的作业。

差的方式（N+1）：
  1. 走到小明桌前："交作业"（第 1 次走动）
  2. 回到讲台
  3. 走到小红桌前："交作业"（第 2 次走动）
  4. 回到讲台
  ... 重复 30 次
  总共走动：31 次（1 次走到教室 + 30 次挨个收）

好的方式（批量）：
  1. 站在讲台上说："所有人把作业传上来"（1 次指令）
  总共走动：1 次
```

在数据库中：
```
差的方式（N+1 查询）：
  查询 1：获取所有文章（SELECT * FROM posts）→ 30 篇文章
  查询 2：获取文章1的作者（SELECT * FROM users WHERE id = 1）
  查询 3：获取文章2的作者（SELECT * FROM users WHERE id = 2）
  ... 重复 30 次
  总查询：31 次

好的方式（2 次查询）：
  查询 1：获取所有文章（SELECT * FROM posts）→ 30 篇文章
  查询 2：获取这些文章的所有作者
         （SELECT * FROM users WHERE id IN (1, 2, 3, ..., 30)）
  总查询：2 次
```

### 具体步骤

**第一步（10分钟）：识别 N+1 问题**

以下页面描述中，哪些有 N+1 问题的风险？

| 页面 | 显示内容 | 有 N+1 风险？ | 为什么？ |
|------|---------|-------------|---------|
| 博客首页 | 显示 20 篇文章，每篇显示作者名字和头像 | | |
| 商品详情页 | 显示 1 个商品的详细信息和 1 个卖家信息 | | |
| 订单列表页 | 显示 50 个订单，每个订单显示商品名称+商品图片 | | |
| 用户个人页 | 显示 1 个用户的信息和他的 10 篇最新文章 | | |
| 评论区 | 显示 100 条评论，每条显示评论者头像+昵称 | | |
| 仪表板 | 显示今日销售额（一个数字） | | |
| 排行榜 | 显示前 50 名用户及其积分、头像、最新发帖 | | |

**第二步（10分钟）：估算性能影响**

假设每次数据库查询需要 5 毫秒：

```
博客首页（20 篇文章 + 作者）：
  N+1 方式：1 + 20 = 21 次查询 × 5ms = 105ms
  优化方式：2 次查询 × 5ms = 10ms
  差距：10.5 倍

订单列表页（50 个订单 + 商品信息）：
  N+1 方式：___ 次查询 × 5ms = ___ms
  优化方式：___ 次查询 × 5ms = ___ms
  差距：___ 倍

排行榜（50 名用户 + 积分 + 头像 + 最新帖子）：
  N+1 方式：___ 次查询 × 5ms = ___ms
  优化方式：___ 次查询 × 5ms = ___ms
  差距：___ 倍
```

**第三步（10分钟）：检查你的项目**

```
对 AI 说：
"请检查我的项目代码，找出所有可能的 N+1 查询问题。

查找模式：
1. 循环中的数据库查询（for 循环里面有 await fetchXxx）
2. 组件中获取关联数据（获取列表后，每个元素单独获取关联数据）
3. ORM 的懒加载（Prisma 的 include 被遗忘的情况）

对每个发现，告诉我：
- 在哪个文件、哪个函数
- 当列表有 N 项时会产生多少次查询
- 如何用批量查询替代"
```

### 评分标准（满分 20 分）

| 维度 | 优秀 (5分) | 合格 (3分) | 不足 (1分) |
|------|-----------|-----------|-----------|
| 识别准确性 | 正确识别所有有 N+1 风险的页面 | 识别出大部分 | 无法识别 |
| 影响量化 | 能计算出具体的查询次数和耗时差异 | 知道有差异但无法量化 | 无法量化 |
| 解决方案 | 知道用批量查询/JOIN/预加载解决 | 知道要优化但不清楚怎么做 | 无方案 |
| 实操能力 | 能写出让 AI 检查项目的提示 | 知道概念但不知道如何检查 | 无法形成可执行方案 |

### 你将学到

- N+1 是最常见的性能杀手，尤其在列表页面
- "每个循环里的数据库查询"是最大的危险信号
- 解决方案很简单：批量查询（WHERE id IN (...)）
- 让 AI 检查 N+1 问题是非常高效的做法

---

## 练习 B4：加载策略决策训练

**练习名称**：「先上菜还是等齐了再上」— 懒加载 vs 预加载

**格式**：为不同的页面元素选择合适的加载策略。

**时间**：35 分钟

### 背景知识（3分钟）

```
预加载 (Eager Loading)：页面一打开就全部加载
  优点：切换页面/功能时立即可用
  缺点：首次加载慢，浪费流量（用户可能不看）
  类比：自助餐一次全拿（可能吃不完）

懒加载 (Lazy Loading)：需要时才加载
  优点：首次加载快，节省流量
  缺点：切换时需要等待加载
  类比：点菜制，吃一道上一道（现做需要等）

预取 (Prefetch)：用户可能需要时提前加载
  优点：需要时已经准备好了
  缺点：可能白白加载了用户不需要的内容
  类比：服务员看你快吃完了，提前准备下一道
```

### 具体步骤

**第一步（15分钟）：加载策略选择**

为以下元素选择加载策略（预加载/懒加载/预取），并写明理由：

| 页面元素 | 加载策略 | 理由 |
|---------|---------|------|
| 首屏的 Hero 大图 | | |
| 页面底部的评论区（需要滚动才能看到） | | |
| 用户头像下拉菜单中的"设置"页面 | | |
| 首页下方的"更多文章"列表 | | |
| 结账页面的支付组件 | | |
| 商品详情页中的"相关推荐"轮播 | | |
| 后台管理面板的图表库（很大，2MB） | | |
| 文章中的第 20 张图片（需要滚动很久才看到） | | |
| 用户很可能点击的"下一页"内容 | | |
| 移动端的桌面版特有功能 | | |
| 暗黑模式的样式文件 | | |
| 第三方聊天支持小窗 | | |

**第二步（10分钟）：代码分割决策**

> 你的 Next.js 应用有以下页面和功能模块，哪些应该代码分割（单独打包，按需加载）？

| 模块 | 大小 | 使用频率 | 分割？ | 理由 |
|------|------|---------|-------|------|
| 首页核心 UI | 50 KB | 每次访问 | | |
| 图表库 (recharts) | 200 KB | 仅管理后台 | | |
| Markdown 编辑器 | 150 KB | 仅发帖时 | | |
| 表单验证库 (zod) | 30 KB | 多个页面使用 | | |
| 日期选择器 | 80 KB | 仅预约功能 | | |
| 用户认证逻辑 | 20 KB | 每次访问 | | |
| PDF 导出功能 | 300 KB | 极少使用 | | |
| 动画库 (framer-motion) | 120 KB | 多处使用 | | |

**第三步（10分钟）：制定加载优先级**

为一个电商首页制定完整的加载优先级时间线：

```
0ms    ────→ 立即加载
  - HTML 骨架
  - 关键 CSS（首屏样式）
  - ____
  - ____

100ms  ────→ 高优先级
  - 首屏商品图片
  - ____
  - ____

500ms  ────→ 中优先级（用户开始交互后）
  - ____
  - ____

2000ms ────→ 低优先级（空闲时）
  - ____
  - ____

用户滚动时 ────→ 按需加载
  - ____
  - ____

用户悬停/意图明显时 ────→ 预取
  - ____
  - ____
```

### 评分标准（满分 20 分）

| 维度 | 优秀 (5分) | 合格 (3分) | 不足 (1分) |
|------|-----------|-----------|-----------|
| 策略选择准确性 | 10/12 以上选择合理 | 8/12 以上合理 | 低于 6/12 |
| 代码分割判断 | 正确识别应分割的大模块 | 大部分正确 | 判断不当 |
| 加载时间线 | 时间线完整且优先级合理 | 有基本时间线 | 无时间线概念 |
| 理由质量 | 每个选择有具体的用户体验理由 | 有基本理由 | 无理由或理由不当 |

### 你将学到

- 加载策略直接影响用户的首次体验
- "首屏以上"的内容最优先，"折叠线以下"可以懒加载
- 代码分割是控制 JS 包大小的关键手段
- 预取是最高级的优化——预测用户行为，提前准备

---

## 练习 B5：CDN 策略设计

**练习名称**：「就近取材」— 让内容从离用户最近的地方送达

**格式**：为给定场景设计 CDN（内容分发网络）策略。

**时间**：30 分钟

### 背景知识（3分钟）

```
没有 CDN：
用户(上海) ──── 4000公里 ──── 服务器(美国) → 200ms 延迟

有 CDN：
用户(上海) ──── 50公里 ──── CDN边缘节点(上海) → 10ms 延迟
                              ↑ 内容从美国服务器同步过来
```

CDN 适合：不变或很少变的内容（图片、CSS、JS、字体）
CDN 不适合：个性化或频繁变化的内容（用户余额、实时聊天）

### 具体步骤

**第一步（10分钟）：分类决策**

将以下内容分为"适合 CDN"和"不适合 CDN"：

| 内容 | CDN 缓存？ | 缓存时长 | 理由 |
|------|----------|---------|------|
| 网站 Logo | | | |
| CSS 样式文件 | | | |
| JavaScript 打包文件 | | | |
| 商品图片 | | | |
| 用户头像 | | | |
| API 响应：商品列表 | | | |
| API 响应：用户购物车 | | | |
| 字体文件 | | | |
| 视频课程内容 | | | |
| 实时股价数据 | | | |
| 用户上传的文件 | | | |
| HTML 页面（首页） | | | |
| HTML 页面（用户个人设置） | | | |
| robots.txt / sitemap.xml | | | |

**第二步（10分钟）：缓存头设计**

为以下资源设计 HTTP 缓存头（Cache-Control）：

```
1. 带版本号的 JS 文件（如 app.a1b2c3.js）
   Cache-Control: ____
   提示：文件名变了 = 新文件，所以可以永久缓存

2. 首页 HTML
   Cache-Control: ____
   提示：需要在新部署后尽快更新

3. 用户头像
   Cache-Control: ____
   提示：不经常变，但变了需要在合理时间内更新

4. API 响应：商品详情
   Cache-Control: ____
   提示：价格可能变化，不能缓存太久

常用 Cache-Control 值参考：
- max-age=31536000, immutable  → 缓存 1 年，不验证
- max-age=3600                → 缓存 1 小时
- max-age=0, must-revalidate  → 每次都验证是否过期
- no-store                    → 完全不缓存
- public                      → CDN 可以缓存
- private                     → 只有浏览器可以缓存，CDN 不可以
```

**第三步（10分钟）：多区域策略**

> 场景：你的应用目标用户分布在中国、东南亚和北美。

设计一个 CDN 策略：

```
CDN 提供商选择：____（提示：Cloudflare、AWS CloudFront、Vercel Edge）

边缘节点区域：
- 中国：____（提示：需要注意中国大陆的特殊要求）
- 东南亚：____
- 北美：____

源站位置：____
  为什么选这里？____

特殊考虑：
- 中国大陆是否需要 ICP 备案？
- 视频内容是否需要单独的 CDN？
- 如何处理 CDN 缓存失效（部署新版本后）？
```

### 评分标准（满分 20 分）

| 维度 | 优秀 (5分) | 合格 (3分) | 不足 (1分) |
|------|-----------|-----------|-----------|
| 分类准确性 | 正确区分所有可缓存/不可缓存内容 | 大部分正确 | 分类混乱 |
| 缓存头设计 | 缓存策略针对性强，时长合理 | 有基本策略 | 全部 no-store 或全部长缓存 |
| 多区域考虑 | 考虑了地理、法规、特殊需求 | 有基本的区域考虑 | 未考虑区域差异 |
| 缓存失效策略 | 有版本化+主动失效方案 | 有基本方案 | 未考虑失效 |

### 你将学到

- CDN 是"用空间换时间"在地理维度的体现
- 静态资源几乎总是应该放在 CDN 上
- 缓存策略的核心是在"快"和"新"之间找平衡
- 不同地区可能有不同的法规和技术限制

---

# 第三章：运维意识 (DevOps & Operations)

> 软件上线不是终点，而是起点。
> "能运行"和"能可靠运行"之间的距离，就是运维能力。
> 你不需要会写运维脚本——你需要知道"应该监控什么"和"出事了怎么办"。

---

## 练习 C1：监控仪表板设计师

**练习名称**：「控制塔」— 设计你的系统监控仪表板

**格式**：为给定的应用设计一个监控仪表板，决定显示哪些指标、如何布局、什么算异常。

**时间**：60 分钟

### 背景知识（5分钟）

监控 = 了解你的系统"健不健康"

```
你的身体：          你的应用：
心率 ────────→ 请求响应时间
体温 ────────→ 错误率
血压 ────────→ CPU/内存使用率
呼吸频率 ───→ 每秒请求数
血氧 ────────→ 可用性（uptime）
```

三支柱：
1. **指标 (Metrics)**：数字——"现在每秒处理多少请求？"
2. **日志 (Logs)**：事件记录——"刚才发生了什么？"
3. **追踪 (Traces)**：调用链——"这个请求经过了哪些环节？"

### 具体步骤

**第一步（15分钟）：选择监控指标**

> 场景：你运营一个在线教育平台（视频课程+作业提交+在线考试）。

从以下指标中选择最重要的 12 个放在你的仪表板上，并按优先级排序：

| 指标 | 选中？ | 优先级 (1=最高) | 理由 |
|------|-------|----------------|------|
| 服务器 CPU 使用率 | | | |
| 服务器内存使用率 | | | |
| 每秒请求数 (RPS) | | | |
| 平均响应时间 | | | |
| P99 响应时间（最慢的 1% 请求） | | | |
| HTTP 5xx 错误率 | | | |
| HTTP 4xx 错误率 | | | |
| 活跃用户数（当前在线） | | | |
| 视频播放成功率 | | | |
| 视频缓冲次数 | | | |
| 数据库查询耗时 | | | |
| 数据库连接池使用率 | | | |
| CDN 缓存命中率 | | | |
| 磁盘使用率 | | | |
| 网络带宽使用率 | | | |
| 作业提交成功率 | | | |
| 支付成功率 | | | |
| 注册转化率 | | | |
| API 第三方调用延迟 | | | |
| 证书到期时间 | | | |

**第二步（20分钟）：设计仪表板布局**

在纸上或 Excalidraw 中画出仪表板布局：

```
仪表板布局模板：

┌──────────────────────────────────────────────┐
│            顶部状态栏（一眼看到整体健康）          │
│  🟢 系统正常  |  ⏱ 响应 120ms  |  ❌ 错误 0.1%   │
├───────────────────┬──────────────────────────┤
│                   │                          │
│   最关键的指标      │    次要指标               │
│   （大号图表）      │    （中号图表）            │
│                   │                          │
│   例：响应时间      │    例：活跃用户数          │
│   折线图           │    折线图                 │
│                   │                          │
├───────────────────┴──────────────────────────┤
│                                              │
│   业务指标区域                                  │
│   视频播放量 | 作业提交 | 新注册用户              │
│                                              │
├──────────────────────────────────────────────┤
│   基础设施指标                                  │
│   CPU | 内存 | 磁盘 | 网络                      │
└──────────────────────────────────────────────┘
```

你来设计具体放什么指标，用什么图表类型：
- 折线图：适合看趋势（随时间变化）
- 数字大卡片：适合看当前值（当前在线人数）
- 仪表盘：适合看百分比（CPU 使用率）
- 柱状图：适合看对比（今天 vs 昨天）

**第三步（15分钟）：设置告警阈值**

为你选择的关键指标设置告警规则：

```
告警规则模板：

指标：HTTP 5xx 错误率
  警告 (Warning)：> 1%（持续 5 分钟）→ 发 Slack 通知
  严重 (Critical)：> 5%（持续 2 分钟）→ 打电话 + 发短信
  恢复 (Recovery)：< 0.5%（持续 5 分钟）→ 发 Slack "已恢复" 通知

指标：平均响应时间
  警告：> ___ ms（持续 ___分钟）→ ____
  严重：> ___ ms（持续 ___分钟）→ ____

指标：视频播放成功率
  警告：< ___% → ____
  严重：< ___% → ____

指标：CPU 使用率
  警告：> ___% （持续 ___分钟）→ ____
  严重：> ___% （持续 ___分钟）→ ____

指标：磁盘使用率
  警告：> ___% → ____
  严重：> ___% → ____

指标：支付成功率
  警告：< ___% → ____
  严重：< ___% → ____
```

**注意告警疲劳**：太多告警 = 没人看告警。规则：
- 每天告警不超过 5 条（正常情况下）
- 每条告警都需要有人响应和行动
- 如果一个告警经常触发但不需要行动 → 调整阈值或删除

**第四步（10分钟）：AI 辅助设置**

```
"我在运营一个在线教育平台，使用以下技术栈：
- Next.js 部署在 Vercel
- 数据库：Supabase (PostgreSQL)
- 视频存储：Cloudflare R2
- 支付：Stripe

我想设置以下监控：
1. Vercel 的性能指标监控
2. Supabase 数据库的查询性能监控
3. 视频播放成功率监控
4. Stripe 支付成功率监控

请告诉我：
- 每个平台原生提供哪些监控能力？
- 我还需要额外安装什么监控工具？（Sentry? UptimeRobot?）
- 最简单的告警配置方案是什么？"
```

### 评分标准（满分 20 分）

| 维度 | 优秀 (5分) | 合格 (3分) | 不足 (1分) |
|------|-----------|-----------|-----------|
| 指标选择 | 覆盖系统+业务+基础设施三层 | 覆盖两层 | 只有一层 |
| 布局设计 | 信息层级清晰，最重要的最突出 | 有布局但层级不清 | 无布局概念 |
| 告警设计 | 阈值合理，避免告警疲劳 | 有告警但阈值可能不合理 | 无告警设计 |
| 可操作性 | 看到告警就知道该做什么 | 知道有问题但不确定该做什么 | 看到数字不知道是好是坏 |

### 你将学到

- 监控是"把问题在用户发现之前找到"的工具
- 好的仪表板在 5 秒内告诉你系统是否健康
- 告警太多 = 没有告警（告警疲劳）
- 业务指标（支付成功率）往往比技术指标（CPU）更重要

---

## 练习 C2：事故响应模拟

**练习名称**：「救火演练」— 系统出事了你该怎么办

**格式**：模拟一个真实的系统故障场景，按照事故响应流程处理。

**时间**：50 分钟

### 背景知识（5分钟）

事故响应的四个阶段：
```
1. 检测 (Detect)    → 发现问题
2. 响应 (Respond)   → 稳定系统
3. 修复 (Remediate) → 根治问题
4. 复盘 (Review)    → 防止再发
```

严重程度分级：
```
P0 — 灾难：系统完全不可用，所有用户受影响
P1 — 严重：核心功能不可用，大量用户受影响
P2 — 重要：部分功能异常，部分用户受影响
P3 — 一般：小问题，少量用户受影响
P4 — 轻微：美观问题，不影响功能
```

### 具体步骤

**第一步（15分钟）：场景模拟**

> 故障场景：周五晚上 8 点（你的在线教育平台的流量高峰）

你收到以下告警：

```
20:00 [WARNING] 平均响应时间上升到 800ms（正常值 150ms）
20:02 [CRITICAL] HTTP 5xx 错误率达到 15%
20:03 [WARNING] 数据库连接池使用率 95%
20:05 [CRITICAL] 用户报告：视频无法播放
20:06 [CRITICAL] 用户报告：无法提交作业
20:08 [WARNING] Twitter 上出现用户抱怨帖子
```

**按照以下模板记录你的响应：**

```
时间线记录：

20:00 — 收到第一个告警
  我的判断：____
  我的行动：____

20:02 — 错误率飙升
  严重程度判定：P___
  理由：____

20:03 — 数据库连接池告警
  我的假设：____（可能原因是什么？）
  下一步检查：____

20:05 — 用户报告视频问题
  沟通行动：____（告诉用户什么？）
  技术行动：____

20:08 — 社交媒体上有抱怨
  公关行动：____
```

**第二步（15分钟）：根因分析**

根据告警模式，推断可能的根本原因：

```
线索汇总：
- 响应变慢 ✓
- 错误率上升 ✓
- 数据库连接池满 ✓
- 视频不能播放 ✓
- 作业不能提交 ✓

可能原因（按可能性排序）：

假设 1：____
  支持证据：____
  反对证据：____
  验证方法：____

假设 2：____
  支持证据：____
  反对证据：____
  验证方法：____

假设 3：____
  支持证据：____
  反对证据：____
  验证方法：____
```

**实际根因揭示**：今天下午部署了一个新版本，新代码中有一个 N+1 查询问题（练习 B3 学过的），在高流量时导致数据库连接被耗尽。

**第三步（10分钟）：处置行动**

```
紧急处置（止血）：
  行动 1：____（提示：回滚到上一个版本？）
  行动 2：____（提示：增加数据库连接池大小？）
  预计恢复时间：____

用户沟通：
  状态页更新内容：____
  社交媒体回复模板：____

根本修复（手术）：
  行动：____（提示：修复 N+1 查询）
  测试计划：____
  重新部署策略：____
```

**第四步（10分钟）：写事后复盘报告**

```
事后复盘 (Postmortem) 模板：

标题：2026-02-16 视频和作业服务中断事故
严重程度：P___
影响时长：___分钟
受影响用户：___人

时间线：
  20:00 - ____
  20:02 - ____
  ...

根本原因：____

影响范围：
  - 用户无法 ____
  - 预估收入损失 ____

做得好的：
  1. ____
  2. ____

做得不好的：
  1. ____
  2. ____

改进措施（带负责人和截止日期）：
  1. [措施] — 负责人：____ — 完成日期：____
  2. [措施] — 负责人：____ — 完成日期：____
  3. [措施] — 负责人：____ — 完成日期：____
```

### 评分标准（满分 20 分）

| 维度 | 优秀 (5分) | 合格 (3分) | 不足 (1分) |
|------|-----------|-----------|-----------|
| 严重程度判定 | 快速准确判定严重级别 | 判定正确但不够快 | 判定不当 |
| 根因分析 | 从线索中逻辑推断出正确原因 | 列出了可能原因但未排序 | 无法分析 |
| 处置行动 | 先止血再根治，有明确优先级 | 有行动但优先级不清 | 行动混乱 |
| 复盘质量 | 有具体的改进措施和负责人 | 有反思但措施不具体 | 无复盘 |

### 你将学到

- 事故响应有明确的流程——不是"慌张修 bug"
- "先止血，再根治"是核心原则
- 用户沟通和技术修复同等重要
- 复盘不是追责，是防止同样的事再发生

---

## 练习 C3：CI/CD 流水线设计师

**练习名称**：「自动工厂」— 设计你的代码到生产的自动化流水线

**格式**：为给定的项目设计一条完整的 CI/CD 流水线，包含所有检查点和决策门。

**时间**：45 分钟

### 背景知识（3分钟）

```
CI = Continuous Integration（持续集成）
  每次推送代码 → 自动运行测试 → 告诉你有没有搞坏东西

CD = Continuous Deployment（持续部署）
  测试全部通过 → 自动部署到生产环境

类比：工厂流水线
  原料（代码）→ 质检（测试）→ 包装（构建）→ 发货（部署）
  任何一步不合格 → 整条线停下，拒绝发货
```

### 具体步骤

**第一步（20分钟）：设计流水线**

> 场景：你的在线商店项目，使用 Next.js + Supabase + Stripe。

设计一条从"开发者提交代码"到"用户看到新功能"的完整流水线：

```
流水线设计模板（填写每一步）：

阶段 1：代码提交
  触发条件：开发者推送代码到 ____（哪个分支？）
  ↓

阶段 2：代码检查
  □ 检查 1：____（提示：代码格式检查？ESLint?）
  □ 检查 2：____（提示：TypeScript 类型检查？）
  □ 检查 3：____（提示：安全漏洞扫描？）
  任何一项失败 → ____（停止？通知？）
  ↓

阶段 3：测试
  □ 测试 1：____（提示：单元测试）
  □ 测试 2：____（提示：集成测试）
  □ 测试 3：____（提示：E2E 测试）
  通过率要求：____（100%？95%？）
  ↓

阶段 4：构建
  □ ____（提示：Next.js 构建）
  □ ____（提示：检查构建大小有没有异常增长）
  ↓

阶段 5：部署到预发布环境
  □ ____
  □ ____（提示：用测试数据验证）
  ↓

阶段 6：（可选）人工审查
  □ ____（提示：产品经理确认功能正确？）
  ↓

阶段 7：部署到生产环境
  □ ____
  □ ____（提示：部署策略——一次性全部还是逐步？）
  ↓

阶段 8：部署后验证
  □ ____（提示：健康检查——首页能打开吗？）
  □ ____（提示：监控——错误率有没有上升？）
  如果异常 → ____（自动回滚？）
```

**第二步（15分钟）：分支策略设计**

设计你的 Git 分支策略：

```
分支策略模板：

main 分支：
  - 代表什么？____（提示：当前生产环境的代码）
  - 谁能直接推送？____
  - 保护规则：____

develop 分支（是否需要？）：
  - ____

feature/* 分支：
  - 命名规则：feature/____
  - 从哪里拉出来？____
  - 合并到哪里？____
  - 合并前要求：____

hotfix/* 分支：
  - 什么时候用？____
  - 从哪里拉出来？____
  - 合并流程：____（提示：既要合并到 main 也要合并到 develop）

环境对应关系：
  feature/* → ____环境
  develop   → ____环境
  main      → ____环境
```

**第三步（10分钟）：故障回滚方案**

```
回滚方案设计：

场景：新版本部署到生产后，发现一个严重 bug。

方案 A：Git 回滚
  步骤：____
  耗时：____
  风险：____

方案 B：平台回滚（Vercel/Railway 的一键回滚）
  步骤：____
  耗时：____
  风险：____

方案 C：蓝绿部署（新旧版本同时运行，切换流量）
  步骤：____
  耗时：____
  风险：____

你的选择：____
理由：____
```

### 评分标准（满分 20 分）

| 维度 | 优秀 (5分) | 合格 (3分) | 不足 (1分) |
|------|-----------|-----------|-----------|
| 流水线完整性 | 包含检查+测试+构建+部署+验证 | 包含大部分阶段 | 遗漏关键阶段 |
| 失败处理 | 每个阶段都有失败后的处理方案 | 部分有 | 未考虑失败 |
| 分支策略 | 清晰的分支→环境映射 | 有基本策略 | 策略混乱 |
| 回滚方案 | 多种回滚方案+选择理由 | 有一种方案 | 无回滚方案 |

### 你将学到

- CI/CD 是"自动化质量保证"——让机器替你检查
- 分支策略决定了团队如何协作
- 回滚能力比"不出 bug"更现实——总会出问题，关键是能快速恢复
- "部署到生产不是终点"——部署后的验证同样关键

---

## 练习 C4：Feature Flag 策略设计

**练习名称**：「开关大师」— 用开关控制功能的生死

**格式**：为新功能设计 Feature Flag（功能开关）策略，决定谁能看到什么功能。

**时间**：35 分钟

### 背景知识（3分钟）

```
Feature Flag = 代码中的开关

没有 Feature Flag：
  部署新功能 = 所有用户立刻看到（如果有 bug，所有人受影响）

有 Feature Flag：
  部署新功能 → 开关关着 → 没人看到
  → 打开开关给 5% 用户 → 观察有没有问题
  → 没问题 → 打开给 50% → 继续观察
  → 没问题 → 打开给 100%

类比：新菜品先让内部员工试吃，再给 VIP 客人尝，最后才放到正式菜单。
```

### 具体步骤

**第一步（15分钟）：设计发布策略**

> 场景：你的电商平台要上线三个新功能：

功能 A：全新的结账流程（涉及支付，风险高）
功能 B：商品推荐算法升级（影响销售额）
功能 C：深色模式（纯 UI 变化，风险低）

为每个功能设计发布策略：

```
功能 A：全新结账流程

发布阶段：
  阶段 1：____ 的人看到新功能
    持续时间：____
    观察指标：____
    进入下一阶段的条件：____

  阶段 2：____ 的人看到新功能
    持续时间：____
    观察指标：____
    进入下一阶段的条件：____

  阶段 3：____ 的人看到新功能
    持续时间：____

回滚条件：如果 ____ 发生，立刻回退到旧版本
回滚方法：关闭 Feature Flag（秒级生效，无需重新部署）

功能 B：推荐算法升级
  ____（你来设计）

功能 C：深色模式
  ____（你来设计）
```

**第二步（10分钟）：A/B 测试设计**

> 功能 B（推荐算法升级）需要 A/B 测试来验证效果。

```
A/B 测试设计：

测试目标：验证新推荐算法是否提升转化率

A 组（对照组）：____% 用户，使用旧算法
B 组（实验组）：____% 用户，使用新算法

核心指标：
  - 主指标：____（提示：点击推荐商品的比例？购买转化率？）
  - 护栏指标：____（提示：确保不影响页面加载速度、不减少浏览时长）

测试持续时间：____（提示：需要足够的样本量）

成功标准：B 组的 ____ 比 A 组高 ____%，且差异统计显著

决策：
  如果 B 胜出 → ____
  如果没有显著差异 → ____
  如果 A 胜出（新算法更差）→ ____
```

**第三步（10分钟）：Flag 生命周期管理**

```
Feature Flag 不是永久的！用完要清理。

Flag 生命周期模板：

Flag 名称：new-checkout-flow
创建日期：2026-02-16
创建原因：降低新结账流程上线风险
负责人：____

生命周期：
  1. 创建 → 2026-02-16
  2. 开发完成 → 2026-02-20（Flag 默认 OFF）
  3. 灰度发布开始 → 2026-02-21（5% 用户）
  4. 全量发布 → 2026-03-01（100% 用户）
  5. 代码清理 → 2026-03-15（移除 Flag 和旧代码）
  6. Flag 删除 → 2026-03-15

⚠️ 警告：如果 Flag 存在超过 30 天且未清理 → 产生技术债务
⚠️ 常见问题：积累了 200 个 Feature Flag，没人知道哪些还在用 → 系统变得不可预测
```

### 评分标准（满分 20 分）

| 维度 | 优秀 (5分) | 合格 (3分) | 不足 (1分) |
|------|-----------|-----------|-----------|
| 灰度策略 | 按风险级别设计不同的发布策略 | 有灰度但策略单一 | 无灰度，全量发布 |
| 指标选择 | 每个阶段有明确的观察指标 | 有指标但不够具体 | 无指标 |
| A/B 测试 | 有对照组、指标、成功标准 | 有基本结构 | 无 A/B 概念 |
| 生命周期 | 有创建→使用→清理的完整流程 | 有使用但无清理计划 | 只有创建 |

### 你将学到

- Feature Flag 让发布和部署解耦——部署不等于发布
- 灰度发布是降低风险的最佳手段
- A/B 测试用数据而不是直觉做决策
- Flag 不清理会变成技术债务

---

## 练习 C5：日志分析侦探

**练习名称**：「日志侦探」— 从日志中还原事故现场

**格式**：阅读一组系统日志，推断发生了什么问题，找到根本原因。

**时间**：40 分钟

### 具体步骤

**第一步（15分钟）：阅读并分析日志**

> 以下是你的电商平台在事故期间的日志（简化版），按时间排序：

```
14:30:01 [INFO]  web-server    Request: GET /api/products - 200 OK (45ms)
14:30:02 [INFO]  web-server    Request: POST /api/orders - 201 Created (120ms)
14:30:15 [INFO]  web-server    Request: POST /api/orders - 201 Created (350ms)
14:30:22 [WARN]  web-server    Request: POST /api/orders - 201 Created (890ms) [SLOW]
14:30:25 [WARN]  database      Connection pool: 45/50 connections in use
14:30:30 [ERROR] web-server    Request: POST /api/orders - 500 Internal Server Error
14:30:30 [ERROR] database      Error: Cannot acquire connection - pool exhausted
14:30:31 [ERROR] web-server    Request: GET /api/products - 500 Internal Server Error
14:30:31 [ERROR] database      Error: Cannot acquire connection - pool exhausted
14:30:32 [WARN]  payment       Stripe webhook received but failed to process: DB unavailable
14:30:33 [ERROR] web-server    Request: POST /api/orders - 500 Internal Server Error
14:30:35 [INFO]  cron-job      Starting: daily-sales-report generation
14:30:35 [INFO]  cron-job      Querying all orders from last 30 days...
14:30:36 [WARN]  database      Connection pool: 50/50 connections in use [FULL]
14:30:36 [ERROR] web-server    10 requests failed in last 10 seconds
14:31:00 [INFO]  cron-job      daily-sales-report: processing 150,000 orders...
14:31:30 [ERROR] web-server    50 requests failed in last 60 seconds
14:32:00 [INFO]  cron-job      daily-sales-report: still processing...
14:35:00 [INFO]  cron-job      daily-sales-report: completed
14:35:01 [INFO]  database      Connection pool: 12/50 connections in use
14:35:02 [INFO]  web-server    Request: GET /api/products - 200 OK (50ms)
14:35:02 [INFO]  web-server    Service restored
```

回答以下问题：

```
1. 事故开始时间：____
2. 事故结束时间：____
3. 事故持续时长：____
4. 最先出现的异常信号：____
5. 根本原因是什么？____

线索分析：
- 14:30:22 响应变慢，说明 ____
- 14:30:25 连接池 45/50，说明 ____
- 14:30:35 cron-job 启动，说明 ____
- 14:35:00 cron-job 完成后系统恢复，说明 ____

结论：____
```

**第二步（10分钟）：设计修复方案**

```
短期修复（今天就做）：
  1. ____（提示：调整 cron-job 的运行时间？）
  2. ____（提示：增加连接池大小？）
  3. ____（提示：给 cron-job 限制连接数？）

长期修复（本周做）：
  1. ____（提示：销售报告改用只读副本数据库？）
  2. ____（提示：报告生成改为异步队列任务？）
  3. ____（提示：连接池监控告警在 80% 时就触发？）
```

**第三步（15分钟）：设计日志规范**

好的日志应该包含什么信息？设计一个日志规范：

```
日志规范模板：

每条日志必须包含：
  - 时间戳：ISO 8601 格式（2026-02-16T14:30:01.234Z）
  - 级别：DEBUG / INFO / WARN / ERROR / FATAL
  - 来源：哪个服务/模块产生的
  - 请求 ID：用于追踪同一个请求的所有日志
  - 消息：发生了什么

可选但推荐：
  - 用户 ID：谁触发的
  - 耗时：操作花了多久
  - 上下文：相关的业务数据（订单号、商品 ID 等）

日志级别使用指南：
  DEBUG：____（什么时候用？）
  INFO ：____
  WARN ：____
  ERROR：____
  FATAL：____

绝对不能出现在日志中的：
  - ____（提示：密码？）
  - ____（提示：信用卡号？）
  - ____（提示：API 密钥？）
```

### 评分标准（满分 20 分）

| 维度 | 优秀 (5分) | 合格 (3分) | 不足 (1分) |
|------|-----------|-----------|-----------|
| 根因分析 | 准确定位 cron-job 导致连接池耗尽 | 知道数据库有问题但不确定原因 | 无法分析 |
| 时间线还原 | 完整还原事故从开始到结束 | 部分还原 | 无法还原 |
| 修复方案 | 短期+长期方案都合理可行 | 有方案但不够完整 | 无方案 |
| 日志规范 | 规范完整且安全（不记录敏感信息） | 有基本规范 | 无规范 |

### 你将学到

- 日志是"事后侦探"的核心工具
- 系统问题往往不是某一个组件的问题，而是组件间的交互问题
- 定时任务和在线服务争抢资源是常见的故障模式
- 日志中绝不能记录敏感信息

---

## 练习 C6：SLA 计算与备份策略

**练习名称**：「承诺书」— 你能承诺多少个9的可用性

**格式**：计算不同级别的 SLA（服务等级协议），设计配套的备份策略。

**时间**：40 分钟

### 背景知识（3分钟）

```
SLA 中的 "9" 代表可用性百分比：

99%    (两个9) = 每年宕机 3.65 天    ← 个人项目足够
99.9%  (三个9) = 每年宕机 8.77 小时  ← 多数 SaaS 的目标
99.99% (四个9) = 每年宕机 52.6 分钟  ← 支付系统等关键服务
99.999%(五个9) = 每年宕机 5.26 分钟  ← 电信级别，极难达到
```

每多一个9，成本和复杂度大约增加 10 倍。

### 具体步骤

**第一步（15分钟）：SLA 设计**

> 场景：你的 SaaS 平台有以下功能模块

为每个模块设定 SLA 目标：

| 功能模块 | SLA 目标 | 每月允许宕机时间 | 理由 |
|---------|---------|---------------|------|
| 用户登录 | ___% | ___ 分钟 | |
| 商品浏览 | ___% | ___ 分钟 | |
| 下单支付 | ___% | ___ 分钟 | |
| 管理后台报表 | ___% | ___ 分钟 | |
| 邮件通知 | ___% | ___ 分钟 | |
| 搜索功能 | ___% | ___ 分钟 | |
| 客服聊天 | ___% | ___ 分钟 | |

**第二步（15分钟）：备份策略设计**

```
备份策略三问：
1. 备份什么？
2. 多久备份一次？
3. 备份保留多久？

数据分类和备份策略：

┌───────────────────────────────────────────────────────┐
│ 数据类别：用户数据（账号、个人信息）                        │
│ 重要程度：★★★★★（丢失 = 灾难）                           │
│ 备份频率：每 ___ 小时                                    │
│ 备份类型：全量备份 + 增量备份                              │
│ 保留期限：___ 天                                        │
│ 备份位置：____（提示：与主数据库不在同一个地区）              │
│ 恢复时间目标 (RTO)：___分钟内恢复                         │
│ 恢复点目标 (RPO)：最多丢失 ___小时的数据                   │
└───────────────────────────────────────────────────────┘

┌───────────────────────────────────────────────────────┐
│ 数据类别：交易记录（订单、支付）                           │
│ 重要程度：★★★★★                                        │
│ 备份频率：____                                         │
│ 保留期限：____（提示：法律可能要求保留7年）                  │
│ 恢复时间目标 (RTO)：____                                │
│ 恢复点目标 (RPO)：____                                  │
└───────────────────────────────────────────────────────┘

┌───────────────────────────────────────────────────────┐
│ 数据类别：用户上传的文件（头像、文档）                      │
│ 重要程度：★★★                                          │
│ 备份频率：____                                         │
│ 保留期限：____                                         │
│ 恢复时间目标 (RTO)：____                                │
│ 恢复点目标 (RPO)：____                                  │
└───────────────────────────────────────────────────────┘

┌───────────────────────────────────────────────────────┐
│ 数据类别：日志数据                                       │
│ 重要程度：★★                                           │
│ 备份频率：____                                         │
│ 保留期限：____                                         │
│ 备份还是不备份？____                                     │
│ 理由：____                                             │
└───────────────────────────────────────────────────────┘
```

**第三步（10分钟）：灾难恢复演练计划**

```
灾难恢复演练计划：

每 ___（月？季度？）进行一次备份恢复演练。

演练内容：
  1. 从备份中恢复数据库到测试环境
  2. 验证恢复的数据是否完整
  3. 测量恢复所需时间
  4. 记录发现的问题

演练清单：
  □ 最近一次备份是什么时候？____
  □ 能在 RTO 时间内恢复吗？____
  □ 恢复后的数据完整吗？____
  □ 恢复流程是否有文档？____
  □ 团队中至少2人知道如何恢复？____

⚠️ 从未测试过的备份 = 没有备份
    （你不知道它是否能恢复，直到你真的试过）
```

### 评分标准（满分 20 分）

| 维度 | 优秀 (5分) | 合格 (3分) | 不足 (1分) |
|------|-----------|-----------|-----------|
| SLA 分级 | 不同模块有不同的 SLA，与重要性匹配 | 有 SLA 但全部相同 | 无 SLA 概念 |
| 备份完整性 | 所有关键数据有备份策略，含 RTO/RPO | 有备份但不完整 | 无备份计划 |
| 备份位置 | 考虑了异地备份 | 有备份但在同一位置 | 未考虑位置 |
| 恢复验证 | 有定期演练计划 | 知道需要演练但无计划 | 未考虑恢复 |

### 你将学到

- 不同功能对可用性的要求不同——不需要全部五个9
- 备份的价值在于恢复——从未恢复测试的备份不可信
- RTO（多快恢复）和 RPO（丢多少数据）是两个关键指标
- 备份是保险——你希望永远不用，但出事时它救你的命

---

# 第四章：数据建模 (Data Modeling)

> 数据模型是应用的骨架。
> 你可以换皮肤（UI）、换肌肉（业务逻辑），但骨架如果设计得不好，整个应用都会"站不直"。
> 先理解数据，再构建功能——这是经验丰富的工程师的直觉。

---

## 练习 D1：ER 图大师赛

**练习名称**：「关系编织」— 复杂业务的实体关系图设计

**格式**：为一个中等复杂度的业务场景绘制完整的 ER 图，包含所有实体、属性、关系、约束。

**时间**：60 分钟

### 具体步骤

**第一步（10分钟）：阅读需求**

> 场景：设计一个在线医疗预约平台的数据模型

功能描述：
- 患者可以注册账号，填写个人信息和病史
- 医院入驻平台，包含多个科室
- 每个科室有多位医生，医生有排班表
- 患者可以按科室/症状/医生搜索并预约
- 预约有状态：待确认→已确认→已就诊→已评价→已取消
- 就诊后医生可以开处方
- 患者可以对医生评价（1-5星+文字评价）
- 支持在线支付挂号费

**第二步（25分钟）：逐步构建 ER 图**

按以下顺序识别实体和关系：

```
第一轮：识别核心实体
  列出所有"名词"：
  - 患者 (Patient)
  - 医院 (Hospital)
  - 科室 (Department)
  - 医生 (Doctor)
  - 预约 (Appointment)
  - 评价 (Review)
  - 处方 (Prescription)
  - 排班 (Schedule)
  - 支付 (Payment)

第二轮：定义每个实体的属性
  对每个实体，问自己：
  - 用什么唯一标识它？（id）
  - 必须记录的信息是什么？
  - 有哪些状态？
  - 什么时候创建？什么时候更新？

  示例——医生 (Doctor)：
  ┌──────────────────────┐
  │       Doctor         │
  ├──────────────────────┤
  │ id (PK)              │
  │ hospital_id (FK)     │ ← 属于哪个医院
  │ department_id (FK)   │ ← 属于哪个科室
  │ name                 │
  │ title                │ ← 职称（主任/副主任/主治/住院）
  │ specialties          │ ← 擅长领域
  │ photo_url            │
  │ bio                  │ ← 简介
  │ years_of_experience  │
  │ consultation_fee     │ ← 挂号费
  │ average_rating       │ ← 平均评分（冗余字段，性能优化）
  │ is_active            │
  │ created_at           │
  │ updated_at           │
  └──────────────────────┘

  你来画出其他所有实体的属性表。

第三轮：定义关系
  ┌────────────┬──────────┬──────────────┬──────────┐
  │ 实体 A     │ 关系     │ 实体 B       │ 类型     │
  ├────────────┼──────────┼──────────────┼──────────┤
  │ Hospital   │ 拥有     │ Department   │ 1:N      │
  │ Department │ 有       │ Doctor       │ 1:N      │
  │ Patient    │ 预约     │ Doctor       │ N:N (通过 Appointment) │
  │ ____       │ ____     │ ____         │ ____     │
  │ ____       │ ____     │ ____         │ ____     │
  │ ____       │ ____     │ ____         │ ____     │
  └────────────┴──────────┴──────────────┴──────────┘
```

**第三步（15分钟）：处理复杂场景**

回答以下设计难题：

```
难题 1：一个医生可以属于多个科室吗？
  如果是，Doctor 和 Department 的关系变成 ____
  需要增加中间表吗？____

难题 2：排班表如何设计？
  方案 A：每天一条记录，包含上午/下午的可预约数
  方案 B：每个时间段一条记录（9:00-9:30, 9:30-10:00...）
  你选择：____
  理由：____

难题 3：average_rating 字段是"冗余"的（可以从 Review 表算出来）。
  为什么要加这个字段？____
  什么时候更新它？____
  如果 Review 表数据和 average_rating 不一致怎么办？____

难题 4：处方中的药品信息如何存储？
  方案 A：直接存药品名称的文本
  方案 B：创建药品实体表，处方中引用药品 ID
  你选择：____
  理由：____

难题 5：患者的病史是结构化数据还是自由文本？
  考虑因素：____
  你的设计：____
```

**第四步（10分钟）：让 AI 审查**

```
"我为在线医疗预约平台设计了以下数据模型：
[你的实体和关系列表]

请审查：
1. 有没有遗漏的实体或重要字段？
2. 关系类型是否正确？
3. 是否考虑了数据一致性？
4. 有没有查询性能的潜在问题？
5. 哪些字段需要建索引？"
```

### 评分标准（满分 20 分）

| 维度 | 优秀 (5分) | 合格 (3分) | 不足 (1分) |
|------|-----------|-----------|-----------|
| 实体完整性 | 识别出 8+ 个实体，含所有核心实体 | 识别出 6+ 个核心实体 | 遗漏关键实体 |
| 属性合理性 | 每个实体有 id、时间戳、状态、外键 | 有基本属性 | 属性不完整 |
| 关系正确性 | 关系类型全部正确，包含中间表 | 大部分正确 | 关系混乱 |
| 复杂场景处理 | 4/5 难题有合理解答 | 3/5 有解答 | 少于 2/5 |

### 你将学到

- 真实业务的数据模型比想象中复杂
- "冗余字段"有时是必要的性能优化
- 多对多关系需要中间表
- 数据设计决策没有绝对正确——只有"在当前场景下更合适"

---

## 练习 D2：规范化 vs 反规范化决策

**练习名称**：「整洁 vs 速度」— 数据要整齐存还是冗余存

**格式**：理解数据库规范化的概念，练习在"规范化（整洁）"和"反规范化（性能）"之间做权衡。

**时间**：45 分钟

### 背景知识（5分钟）

```
规范化 = 数据不重复，每个信息只存一份
  优点：数据一致，修改只需改一处
  缺点：查询需要 JOIN 多张表，性能可能差

反规范化 = 故意冗余存储，减少查询时的 JOIN
  优点：查询快，一张表就搞定
  缺点：数据可能不一致，修改要改多处

类比：
  规范化 = 公司只有一个电话簿，所有部门查同一本
         → 改号码只改一次，但查号码要去一个地方
  反规范化 = 每个部门复印一份电话簿
         → 查号码很快（就在手边），但改号码要改所有副本
```

### 具体步骤

**第一步（15分钟）：规范化分析**

> 以下是一个"不规范"的订单表设计，分析它的问题：

```
订单表 (orders) — 反规范化版本：
┌──────────────────────────────────┐
│ order_id                         │
│ order_date                       │
│ customer_name        ← 问题？    │
│ customer_email       ← 问题？    │
│ customer_phone       ← 问题？    │
│ customer_address     ← 问题？    │
│ product_name         ← 问题？    │
│ product_price        ← 问题？    │
│ product_category     ← 问题？    │
│ quantity                         │
│ total_amount                     │
│ payment_method                   │
│ shipping_address                 │
│ order_status                     │
└──────────────────────────────────┘
```

分析问题：

```
问题 1：如果客户改了手机号，需要改多少条记录？
  答：____（提示：这个客户的所有历史订单都要改）

问题 2：如果商品改了名称，需要改多少条记录？
  答：____

问题 3：如果同一个商品出现在 1000 个订单中，商品信息被存储了多少次？
  答：____

问题 4：如果客户还没下过单，他的信息在哪里？
  答：____（提示：规范化版本有独立的 customers 表）
```

**第二步（15分钟）：规范化改造**

将上面的表拆分为规范化的多张表：

```
你来设计以下表的结构：

customers 表：
  ____

products 表：
  ____

orders 表（只包含订单本身的信息+外键）：
  ____

order_items 表（订单和商品的关系）：
  ____
```

**第三步（15分钟）：反规范化决策**

现在反过来思考——什么情况下应该故意反规范化？

| 场景 | 规范化？ | 反规范化？ | 理由 |
|------|---------|----------|------|
| 订单中的商品价格（下单时的价格，不受后续涨价影响） | | | |
| 订单中的收货地址（下单时的地址，即使用户后来搬家也不变） | | | |
| 文章列表页显示作者名字（每次都 JOIN users 表？） | | | |
| 商品详情页显示分类名称 | | | |
| 用户个人页显示"总帖子数" | | | |
| 排行榜显示用户积分 | | | |
| 搜索结果显示的商品信息 | | | |

对每个选择"反规范化"的场景，回答：
1. 冗余数据存在哪里？
2. 什么时候同步/更新冗余数据？
3. 如果数据不一致了怎么发现和修复？

### 评分标准（满分 20 分）

| 维度 | 优秀 (5分) | 合格 (3分) | 不足 (1分) |
|------|-----------|-----------|-----------|
| 问题识别 | 准确指出所有冗余和异常 | 发现大部分问题 | 看不出问题 |
| 规范化设计 | 拆分合理，外键正确 | 基本拆分正确 | 拆分不当 |
| 反规范化判断 | 5/7 以上场景判断正确 | 4/7 正确 | 少于 3/7 |
| 一致性意识 | 每个反规范化都有同步策略 | 部分有策略 | 未考虑一致性 |

### 你将学到

- 规范化消除数据冗余，反规范化提升查询性能
- 订单中的价格和地址是"快照"——应该反规范化（记录下单时的状态）
- "读多写少"的场景更适合反规范化
- 反规范化的代价是维护数据一致性的额外工作

---

## 练习 D3：数据迁移规划

**练习名称**：「搬家计划」— 数据库结构变更的安全计划

**格式**：为一个"正在运行的系统"规划数据库结构变更，确保零停机时间。

**时间**：45 分钟

### 背景知识（3分钟）

```
数据迁移 = 修改正在使用的数据库结构

为什么难？
  想象一下：在高速公路上换轮胎。车（应用）不能停，但轮胎（数据库结构）要换。

常见迁移类型：
  1. 加新表/加新列 — 通常安全
  2. 删列/删表 — 危险（数据可能丢失）
  3. 改列类型 — 中等（可能导致数据截断）
  4. 拆表/合表 — 复杂（需要迁移数据）
  5. 重命名列 — 看似简单实则危险（代码还在用旧名字）
```

### 具体步骤

**第一步（20分钟）：迁移场景规划**

> 场景：你的电商平台需要以下变更，为每个变更制定迁移计划。

**变更 1：用户表增加"手机号"字段**

```
迁移计划：

当前状态：users 表没有 phone 字段
目标状态：users 表有 phone 字段（可选，VARCHAR(20)）

步骤：
  1. 添加列：ALTER TABLE users ADD COLUMN phone VARCHAR(20)
  2. 这个操作会锁表吗？____（提示：大多数现代数据库不会）
  3. 需要停机吗？____
  4. 旧代码会受影响吗？____（提示：新列可以为 NULL，旧代码不受影响）
  5. 回滚方案：____

风险评估：低 / 中 / 高
理由：____
```

**变更 2：将 orders 表中的 address（文本）拆分为独立的 addresses 表**

```
迁移计划：

当前状态：orders.address = "北京市朝阳区xxx路xxx号"（一个字符串）
目标状态：独立的 addresses 表（city, district, street, detail）
          orders 表通过 shipping_address_id 关联

步骤（三阶段迁移）：

阶段 1 — 扩展（只加不减）：
  1. 创建 addresses 表
  2. orders 表加 shipping_address_id 列
  3. 编写脚本将旧 address 数据解析并填入 addresses 表
  4. 更新 shipping_address_id
  5. 此时 orders 表同时有旧字段和新字段

阶段 2 — 迁移代码：
  1. 修改代码，新订单写入 addresses 表+shipping_address_id
  2. 读取时优先用 shipping_address_id，后备用旧 address
  3. 部署新代码
  4. 验证一段时间（____天）

阶段 3 — 清理：
  1. 确认所有订单都有 shipping_address_id
  2. 删除旧 address 列
  3. 部署只使用新方式的代码

为什么不能一步到位？____
回滚方案：每个阶段都可以回退到上一个阶段
```

**变更 3：将用户 email 从大小写混存改为全部小写**

```
迁移计划：

问题：有些用户注册时用了 "John@Email.Com"，有些用了 "john@email.com"
     导致搜索和去重出现问题

步骤：
  1. ____（提示：先检查有没有大小写不同但实际相同的邮箱）
  2. 处理冲突：如果 "John@email.com" 和 "john@email.com" 都存在怎么办？
     ____
  3. ____（转换所有邮箱为小写）
  4. ____（代码层面确保新注册的邮箱也是小写）
  5. ____（添加数据库约束确保只接受小写）

风险：____
回滚方案：____（提示：能回滚吗？小写化是单向的）
```

**第二步（15分钟）：迁移检查清单**

制定一个通用的数据迁移检查清单：

```
迁移前检查：
  □ 当前表有多少行数据？____
  □ 迁移脚本在测试环境跑过了吗？____
  □ 迁移需要多长时间？（用测试数据估算）____
  □ 迁移期间应用需要停机吗？____
  □ 有完整的数据库备份吗？____
  □ 回滚方案写好了吗？____
  □ 回滚方案测试过了吗？____

迁移中检查：
  □ 是否有监控在运行？____
  □ 错误率有没有上升？____
  □ 迁移进度如何追踪？____

迁移后检查：
  □ 数据完整性验证通过了吗？____
  □ 应用功能正常吗？____
  □ 新旧数据一致吗？____
  □ 性能有变化吗？____
```

**第三步（10分钟）：向 AI 提交迁移请求**

```
"我需要修改生产数据库结构：
[描述变更]

当前数据量：orders 表 50 万行，users 表 10 万行
使用 Supabase (PostgreSQL)
应用部署在 Vercel

请帮我设计：
1. 零停机时间的迁移方案
2. 迁移脚本（分阶段）
3. 每个阶段的回滚方案
4. 数据验证脚本（确认迁移正确）
5. 迁移前后的性能对比检查点"
```

### 评分标准（满分 20 分）

| 维度 | 优秀 (5分) | 合格 (3分) | 不足 (1分) |
|------|-----------|-----------|-----------|
| 分阶段意识 | 所有复杂迁移都有多阶段方案 | 部分有多阶段 | 试图一步到位 |
| 回滚方案 | 每个阶段都有独立的回滚方案 | 有回滚方案但不完整 | 无回滚方案 |
| 风险意识 | 考虑了数据丢失、冲突、性能影响 | 考虑了部分风险 | 未考虑风险 |
| 实操性 | 检查清单完整可执行 | 有基本步骤 | 步骤不清 |

### 你将学到

- 数据库迁移必须可逆——总要有回滚方案
- "只加不减"是最安全的迁移策略
- 复杂迁移需要分多个阶段，每个阶段都可以独立回滚
- 生产环境的迁移永远比测试环境复杂

---

## 练习 D4：Schema 演进设计

**练习名称**：「进化论」— 数据模型如何随业务进化

**格式**：模拟一个产品从 MVP 到成熟的过程，观察数据模型如何一步步演进。

**时间**：50 分钟

### 具体步骤

**第一步（10分钟）：V1 — MVP 阶段**

> 场景：你在做一个简单的"读书笔记"应用，MVP 版本只需要最基本的功能。

```
V1 需求：
- 用户可以记录读书笔记
- 每条笔记包含书名、内容、日期

设计最简单的数据模型：

notes 表：
  id
  user_id
  book_title    ← 就是一个文本字段
  content
  created_at

这够用吗？对 MVP 来说 ____
```

**第二步（10分钟）：V2 — 增加书籍管理**

```
V2 需求：
- 用户反馈：同一本书的笔记应该归到一起
- 想看到"这本书我记了多少笔记"
- 想加上书的封面图和作者

你的设计：
  需要增加什么表？____
  需要修改什么表？____
  旧数据怎么迁移？____（book_title 字段的数据怎么办？）

画出 V2 的数据模型：
```

**第三步（10分钟）：V3 — 增加社交功能**

```
V3 需求：
- 用户可以将笔记设为"公开"
- 其他用户可以点赞和评论公开笔记
- 用户可以关注其他用户
- 首页显示关注用户的最新公开笔记

你的设计：
  需要增加什么表？____
  notes 表需要加什么字段？____
  关注关系如何存储？____

新的 ER 图（在 V2 基础上扩展）：
```

**第四步（10分钟）：V4 — 增加读书俱乐部**

```
V4 需求：
- 用户可以创建/加入读书俱乐部
- 俱乐部有共读计划（一起读某本书，有进度和截止日期）
- 俱乐部成员可以在俱乐部内讨论

你的设计：
  需要增加什么表？____
  和现有表的关系？____
  共读计划如何与书籍和用户关联？____

最终 ER 图：
```

**第五步（10分钟）：回顾与反思**

```
回顾问题：

1. 如果你在 V1 就设计了 V4 的所有表，会怎样？
   ____（提示：过度设计，大部分表可能永远用不到）

2. V1 → V2 的迁移最痛苦的地方是什么？
   ____（提示：book_title 字段拆分成独立的 books 表）

3. 有没有什么 V1 的设计决策让后续版本变得更难？
   ____

4. 如果能重来，V1 的设计你会改什么？
   ____

5. 这个演进过程对你设计新项目有什么启示？
   ____（提示：MVP 简单但预留扩展空间）
```

### 评分标准（满分 20 分）

| 维度 | 优秀 (5分) | 合格 (3分) | 不足 (1分) |
|------|-----------|-----------|-----------|
| V1 简洁性 | MVP 足够简单，不过度设计 | 有些多余但不严重 | MVP 就搞了10张表 |
| 演进合理性 | 每个版本自然扩展，不推翻重来 | 大部分合理 | 每个版本都重新设计 |
| 迁移意识 | 每次变更都考虑旧数据如何处理 | 部分考虑 | 忽略旧数据 |
| 反思质量 | 能总结出实用的设计原则 | 有基本反思 | 无反思 |

### 你将学到

- 数据模型应该随业务"进化"而非"预测未来"
- MVP 的数据模型应该尽可能简单
- 每次演进都是一次迁移挑战
- "预留扩展空间"不等于"提前实现所有表"

---

## 练习 D5：软删除 vs 硬删除决策

**练习名称**：「删还是藏」— 数据要真删还是假删

**格式**：分析不同场景下应该使用软删除还是硬删除，理解各自的代价。

**时间**：35 分钟

### 背景知识（3分钟）

```
硬删除 (Hard Delete)：
  DELETE FROM users WHERE id = 123
  → 数据从数据库中永久消失
  → 如同把文件丢进碎纸机

软删除 (Soft Delete)：
  UPDATE users SET deleted_at = '2026-02-16', is_deleted = true WHERE id = 123
  → 数据还在，但被标记为"已删除"
  → 如同把文件放进回收站
  → 查询时加条件：WHERE is_deleted = false
```

### 具体步骤

**第一步（15分钟）：场景决策**

为每个场景选择软删除或硬删除，并详细说明理由：

| 场景 | 软/硬删除 | 理由 | 注意事项 |
|------|----------|------|---------|
| 用户注销账号 | | | |
| 删除聊天消息 | | | |
| 删除草稿笔记 | | | |
| 取消订阅（付费用户降级） | | | |
| 管理员封禁用户 | | | |
| 用户删除已发布的评论 | | | |
| 过期的促销活动 | | | |
| 用户删除上传的照片 | | | |
| 删除购物车中的商品 | | | |
| 系统清理30天前的日志 | | | |
| 删除测试/假数据 | | | |
| GDPR"被遗忘权"请求 | | | |

**第二步（15分钟）：软删除的隐藏代价**

分析软删除带来的问题：

```
问题 1：查询性能
  所有查询都要加 WHERE is_deleted = false
  如果忘了加这个条件？____
  随着时间推移，"已删除"数据越来越多？____

问题 2：唯一性约束
  用户 A 注册了 email "test@test.com"
  用户 A 注销（软删除）
  用户 B 想用 "test@test.com" 注册
  → 结果：____
  → 解决方案：____（提示：唯一约束需要排除已删除记录，或者换一种方式）

问题 3：关联数据
  用户被软删除了，但他的帖子、评论、订单还在
  显示这些数据时作者显示什么？____
  如果有人 @了这个用户怎么显示？____

问题 4：存储成本
  如果你从不真正删除数据，数据量只会增长
  5年后你的"已删除"数据可能比"活跃"数据还多
  怎么处理？____（提示：定期归档？移到冷存储？）

问题 5：法律合规
  GDPR 要求"被遗忘权"——用户要求删除他的所有数据
  软删除满足 GDPR 要求吗？____
  你需要做什么？____
```

**第三步（5分钟）：设计你的删除策略模板**

```
删除策略模板（适用于你的所有项目）：

默认策略：____（软删除 or 硬删除？）

使用软删除的条件：
  □ 数据有审计或合规需求
  □ 数据可能需要恢复
  □ 数据被其他记录引用
  □ ____（你的补充条件）

使用硬删除的条件：
  □ 临时数据/缓存数据
  □ 用户明确要求永久删除（GDPR）
  □ 测试/假数据
  □ ____（你的补充条件）

软删除实施规范：
  字段名：deleted_at (TIMESTAMP, nullable)
  查询规范：所有查询默认加 WHERE deleted_at IS NULL
  归档策略：超过 ___天 的已删除数据移至归档表
  合规策略：收到 GDPR 请求后 ___天 内硬删除
```

### 评分标准（满分 20 分）

| 维度 | 优秀 (5分) | 合格 (3分) | 不足 (1分) |
|------|-----------|-----------|-----------|
| 场景判断 | 10/12 以上判断合理 | 8/12 以上合理 | 低于 6/12 |
| 代价认识 | 识别出所有5个隐藏代价 | 识别出3-4个 | 少于2个 |
| 唯一性处理 | 有明确的唯一约束解决方案 | 意识到问题但无方案 | 未意识到问题 |
| 策略模板 | 模板完整且包含归档和合规 | 有基本模板 | 无策略 |

### 你将学到

- "删除"比想象中复杂——不是一个简单的 DELETE
- 软删除有隐藏代价：查询复杂度、唯一约束冲突、存储增长
- GDPR 等法规要求真正的删除——软删除可能不够
- 没有"一刀切"的策略——根据数据类型和场景选择

---

# 附录：练习总览与进度追踪

## 所有练习一览表

| 编号 | 练习名称 | 领域 | 时间 | 难度 | 完成 |
|------|---------|------|------|------|------|
| A1 | 数据蓝图 — ER 图设计 | 架构 | 60 min | ★★☆ | □ |
| A2 | API 菜单 — REST API 设计 | 架构 | 45 min | ★★☆ | □ |
| A3 | 缓存棋局 — 缓存策略 | 架构 | 45 min | ★★★ | □ |
| A4 | 异步厨房 — 队列/异步处理 | 架构 | 40 min | ★★☆ | □ |
| A5 | 拆还是不拆 — 单体 vs 微服务 | 架构 | 45 min | ★★☆ | □ |
| A6 | 状态流转图 — 状态机设计 | 架构 | 45 min | ★★★ | □ |
| A7 | 流量闸门 — 速率限制设计 | 架构 | 40 min | ★★☆ | □ |
| A8 | 只收一次钱 — 幂等性 | 架构 | 35 min | ★★★ | □ |
| A9 | 多米诺骨牌 — 依赖关系分析 | 架构 | 40 min | ★★☆ | □ |
| B1 | 网站体检 — Core Web Vitals | 性能 | 60 min | ★☆☆ | □ |
| B2 | 图片瘦身 — 图片优化 | 性能 | 40 min | ★☆☆ | □ |
| B3 | 一百次还是一次 — N+1 问题 | 性能 | 35 min | ★★☆ | □ |
| B4 | 先上菜还是等齐了再上 — 加载策略 | 性能 | 35 min | ★★☆ | □ |
| B5 | 就近取材 — CDN 策略 | 性能 | 30 min | ★★☆ | □ |
| C1 | 控制塔 — 监控仪表板设计 | 运维 | 60 min | ★★☆ | □ |
| C2 | 救火演练 — 事故响应模拟 | 运维 | 50 min | ★★★ | □ |
| C3 | 自动工厂 — CI/CD 流水线 | 运维 | 45 min | ★★☆ | □ |
| C4 | 开关大师 — Feature Flag | 运维 | 35 min | ★★☆ | □ |
| C5 | 日志侦探 — 日志分析 | 运维 | 40 min | ★★★ | □ |
| C6 | 承诺书 — SLA 与备份策略 | 运维 | 40 min | ★★☆ | □ |
| D1 | 关系编织 — 复杂 ER 图 | 数据 | 60 min | ★★★ | □ |
| D2 | 整洁 vs 速度 — 规范化决策 | 数据 | 45 min | ★★★ | □ |
| D3 | 搬家计划 — 数据迁移 | 数据 | 45 min | ★★★ | □ |
| D4 | 进化论 — Schema 演进 | 数据 | 50 min | ★★☆ | □ |
| D5 | 删还是藏 — 软删除 vs 硬删除 | 数据 | 35 min | ★★☆ | □ |

## 推荐学习路径

```
第 1 周：基础直觉建立
  ├── A1 数据蓝图（画 ER 图的基本功）
  ├── A2 API 菜单（理解服务通信）
  ├── B1 网站体检（用工具诊断性能）
  └── B2 图片瘦身（最简单的优化）

第 2 周：深入架构
  ├── A4 异步厨房（同步 vs 异步）
  ├── A5 拆还是不拆（架构决策）
  ├── A6 状态流转图（业务逻辑建模）
  └── B3 N+1 问题（数据库性能直觉）

第 3 周：运维意识
  ├── C1 控制塔（监控设计）
  ├── C2 救火演练（事故响应）
  ├── C3 自动工厂（CI/CD）
  └── C5 日志侦探（日志分析）

第 4 周：高级主题
  ├── A3 缓存棋局（缓存策略）
  ├── A7 流量闸门（速率限制）
  ├── A8 只收一次钱（幂等性）
  └── A9 多米诺骨牌（依赖分析）

第 5 周：数据建模
  ├── D1 关系编织（复杂 ER 图）
  ├── D2 整洁 vs 速度（规范化）
  ├── D3 搬家计划（数据迁移）
  └── D4 进化论（Schema 演进）

第 6 周：综合与收尾
  ├── B4 加载策略
  ├── B5 CDN 策略
  ├── C4 Feature Flag
  ├── C6 SLA 与备份
  └── D5 软删除 vs 硬删除
```

## 成长评估标准

### 入门级（完成 8 个练习后）
- 能画基本的 ER 图
- 知道 N+1 问题是什么
- 能用 PageSpeed Insights 分析网站
- 理解同步 vs 异步的区别

### 中级（完成 18 个练习后）
- 能为中等复杂度的系统设计数据模型
- 能识别过度设计 vs 欠设计
- 能设计基本的监控和告警方案
- 理解缓存、队列、状态机等核心概念
- 能写出让 AI 产出更好代码的架构描述

### 高级（完成全部 25 个练习后）
- 能独立评审一个系统的架构合理性
- 能在简单/快速和完善/复杂之间做出合理权衡
- 能设计完整的 CI/CD 流水线和事故响应流程
- 能规划零停机的数据库迁移
- 拥有"这个设计会在哪里出问题"的直觉

---

> **核心信念**：
>
> 你不需要会写 SQL 就能设计好的数据模型。
> 你不需要会写 YAML 就能设计好的 CI/CD 流水线。
> 你不需要会写监控代码就能知道该监控什么。
>
> **你需要的是判断力——知道什么重要、什么危险、什么可以简化、什么必须严谨。**
>
> 这些练习训练的不是技术技能，而是**工程直觉**。
> 有了这些直觉，你给 AI 的指令会从"做个网站"变成"设计一个有缓存层、状态机管理、N+1 防护、灰度发布的生产级系统"。
>
> 那就是品味。

---

*练习手册设计日期：2026年2月16日*
*覆盖领域：架构设计（9个）、性能优化（5个）、运维意识（6个）、数据建模（5个）*
*总计 25 个练习 + 3 个 bonus 练习（来自 CURRICULUM-EXTENDED.md 的 A1/A2/A3）= 28 个练习*
