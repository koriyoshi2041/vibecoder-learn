# 2026 Vibe Coder 进阶之路：扩展篇

> **本文档是 CURRICULUM.md 的扩展**，包含两大部分：
> 1. **拓展项目系列** — 覆盖主线之外的重要领域
> 2. **品味锻造挑战** — 一系列培养直觉、判断力和"好品味"的练习
>
> **设计日期**：2026年2月

---

# 第一部分：拓展项目系列

> 这些项目与主线7个项目平行，可以在完成主线 Project 2-3 之后开始穿插进行。
> 每个项目聚焦一个**不同的产品形态**，教授主线项目未覆盖的技能维度。

---

## E1: 「效率利刃」— Chrome 浏览器扩展

**你要构建的东西**：一个解决你日常痛点的浏览器扩展——比如网页内容摘要器、标签页管理器、阅读模式增强器、或特定网站的效率工具。发布到 Chrome 应用商店。

**为什么需要这个项目**：浏览器扩展是最"触手可及"的产品形态——不需要服务器、不需要数据库，直接在用户的浏览器里运行。但它引入了一个全新的概念：**你的代码运行在别人的环境里**。

### 引入的新能力

| 能力 | 具体内容 |
|------|---------|
| 运行环境理解 | 客户端 vs 服务端 vs 扩展环境——三种完全不同的世界 |
| 权限模型 | 扩展需要请求权限（读取网页、存储数据等）——最小权限原则 |
| 消息传递 | Background Script ↔ Content Script ↔ Popup 之间的通信 |
| 发布流程 | Chrome Web Store 审核流程、版本管理、更新推送 |
| 隐私意识 | 扩展能读取用户的所有网页内容——这是巨大的责任 |

### 高层知识

- **最小权限原则**：只请求你绝对需要的权限。一个"标签管理器"不需要"读取所有网页内容"的权限。用户看到过多权限请求会立刻拒绝安装。
- **沙箱思维**：扩展运行在一个受限环境中，有些事做得到，有些做不到。理解边界比试图突破边界更重要。
- **分发渠道**：从"部署到服务器"变成了"发布到应用商店"——审核流程、政策合规、用户评价是新的挑战。

### 实战提示

```markdown
# 好的提示
"创建一个 Chrome 扩展，功能是：
1. 当用户在任意网页上选中文本时，显示一个浮动按钮
2. 点击按钮后，将选中文本发送到 Claude API 获取摘要
3. 在一个优雅的侧边栏中显示摘要结果
4. 摘要历史存储在 chrome.storage.local 中

技术要求：
- 使用 Manifest V3
- Content Script 负责检测选中文本和显示 UI
- Background Service Worker 负责 API 调用
- 使用最小权限：只需要 activeTab、storage 和 host_permissions
- API 密钥存储在 chrome.storage.sync 中，不硬编码

安全：不在 Content Script 中直接调用外部 API。"
```

### 你将获得

- Chrome 应用商店上的真实产品
- 对"代码运行在哪里"的深刻理解
- 权限和隐私的直觉——这是所有软件的基础伦理

---

## E2: 「自动化引擎」— 工作流自动化系统

**你要构建的东西**：一个自动化工作流系统，连接多个服务。例如：新邮件 → AI 分类 → 自动回复/转发/存档；社交媒体监控 → AI 分析 → 报告生成；GitHub Issue → AI 分析 → 自动标签/分配。使用 n8n（自托管）或 Make/Zapier。

**为什么需要这个项目**：编程的本质是自动化。这个项目教你不写一行"应用代码"也能构建强大的系统——通过**连接现有服务**。这是"编排思维"的最纯粹体现。

### 引入的新能力

| 能力 | 具体内容 |
|------|---------|
| 事件驱动思维 | 不是"用户点击"触发，而是"事件发生"触发——邮件到达、文件上传、定时器触发 |
| 服务集成 | 连接 Gmail、Slack、GitHub、Notion 等第三方 API |
| 错误处理策略 | 如果中间一步失败了怎么办？重试？跳过？通知？ |
| 幂等设计 | 同一个事件触发两次，结果应该一样 |
| n8n 自托管 | 在 Railway 上部署 n8n——理解容器和自托管概念 |
| AI 作为工作流节点 | 在工作流中嵌入 AI 分析/分类/生成步骤 |

### 高层知识

- **事件驱动 vs 请求驱动**：Web 应用是"用户请求，系统响应"。自动化是"事件发生，系统反应"。这是两种根本不同的思维模式。理解事件驱动让你能设计更智能的系统。
- **管道思维**：数据像水一样流过管道——每个节点做一件事，输出传给下一个节点。管道的任何一段都可能堵塞（失败），你需要排水口（错误处理）。
- **编排的纯粹形态**：你没有写任何"代码"——你在连接服务、定义规则、设计流程。这就是 agentic engineering 的核心：不实现，而是编排。

### 具体工作流示例

```
工作流 1：智能邮件助手
触发器：收到新邮件
  → 节点1：提取邮件内容
  → 节点2：AI 分类（紧急/普通/垃圾/需回复）
  → 分支：
    - 紧急 → Slack 通知 + 手机推送
    - 需回复 → AI 起草回复 → 存入草稿
    - 垃圾 → 自动归档
    - 普通 → 打标签存档

工作流 2：竞品监控
触发器：每天早上 9:00
  → 节点1：抓取竞品网站/社交媒体
  → 节点2：AI 分析变化和趋势
  → 节点3：生成日报
  → 节点4：发送到 Slack/邮件

工作流 3：GitHub 自动化
触发器：新 Issue 创建
  → 节点1：AI 分析 Issue 内容
  → 节点2：自动打标签（bug/feature/question）
  → 节点3：分配给对应团队成员
  → 节点4：如果是 bug，自动在代码库中搜索相关文件
```

### 你将获得

- 多个真实运行的自动化工作流
- 事件驱动思维——从"响应请求"到"响应事件"的飞跃
- 纯粹的编排体验——不写代码也能构建复杂系统

---

## E3: 「掌上助手」— 移动应用

**你要构建的东西**：一个移动端应用——习惯追踪器、个人记账、健身日志、或任何你会每天在手机上使用的工具。使用 React Native + Expo，通过 Replit 或 VibeCode 构建，发布到 App Store/Google Play。

**为什么需要这个项目**：移动应用是完全不同的设计思维——小屏幕、触摸交互、离线能力、推送通知。这些约束迫使你思考"真正重要的是什么"。

### 引入的新能力

| 能力 | 具体内容 |
|------|---------|
| 移动优先设计 | 小屏幕上什么最重要？触摸目标多大才够用？ |
| 离线能力 | 没网的时候应用应该怎么工作？数据同步策略 |
| 推送通知 | 如何在不骚扰用户的情况下发送有价值的通知 |
| 应用商店发布 | App Store / Google Play 的审核、截图、描述、定价 |
| 本地存储 | SQLite / AsyncStorage——数据在设备上的存储 |
| 原生功能 | 相机、GPS、传感器——利用手机硬件 |

### 高层知识

- **移动 ≠ 缩小的网页**：移动应用有完全不同的交互模式——滑动、长按、手势、震动反馈。好的移动应用"感觉"对了，因为它尊重平台的设计语言。
- **离线优先思维**：Web 应用假设"总是在线"。移动应用必须假设"可能离线"。这改变了你设计数据流的方式。
- **推送通知是特权**：用户授予你推送通知的权限是信任行为。滥用它（频繁、无关的通知）会导致用户卸载。每条通知都应该提供价值。
- **分发是另一个产品**：应用商店页面（截图、描述、评价）本身就是一个"产品"——它决定了用户是否会下载你的应用。

### 你将获得

- 手机上真实可用的应用
- 移动端设计思维——约束产生创造力
- 应用商店发布的完整经验

---

## E4: 「数据透镜」— 数据分析仪表板

**你要构建的东西**：一个数据分析和可视化仪表板——可以是个人财务分析、社交媒体数据追踪、业务 KPI 面板、或公开数据探索工具。将数据转化为可操作的洞察。

**为什么需要这个项目**：数据是现代商业的燃料。这个项目不教你"做数据科学"，而是教你"用数据说话"——如何收集、清洗、可视化和解读数据。

### 引入的新能力

| 能力 | 具体内容 |
|------|---------|
| 数据管道 | 数据从哪来？如何定时获取和更新？ETL 概念 |
| 数据可视化 | 什么图表最适合什么数据？柱状图 vs 折线图 vs 散点图 |
| 数据清洗 | 真实数据是脏的——缺失值、异常值、格式不一致 |
| 仪表板设计 | 信息层级——最重要的数字放最大、最突出 |
| 定时任务 | Cron Jobs——让数据自动更新 |
| 数据叙事 | 不只是展示数据，而是讲述数据背后的故事 |

### 高层知识

- **数据不会说谎，但可以误导**：同样的数据，不同的图表类型、不同的时间范围、不同的坐标轴可以讲述完全不同的故事。理解这一点是数据素养的核心。
- **ETL 是什么**：Extract（提取）→ Transform（转换）→ Load（加载）。数据从原始来源到可用状态需要经过这三步。
- **仪表板的黄金法则**：一个仪表板应该在5秒内回答一个问题。如果需要超过5秒才能理解，就需要简化。
- **实时 vs 批处理**：有些数据需要实时更新（股价），有些每天更新就够了（营收报告）。选择合适的更新频率影响成本和复杂度。

### 你将获得

- 一个真实的数据分析工具
- 数据思维——从"感觉"到"证据"的转变
- 数据可视化的直觉——什么图表讲什么故事

---

## E5: 「命令行魔法」— CLI 工具与本地自动化

**你要构建的东西**：一个命令行工具，解决你的日常重复工作——批量文件重命名、项目脚手架生成器、本地 AI 文档处理器、或开发环境自动配置器。通过 npm/pip 发布，让其他人也能安装使用。

**为什么需要这个项目**：命令行是最纯粹的"人机对话"——没有图形界面的干扰，只有输入和输出。学会在终端工作是理解 Claude Code 和 AI 代理运作方式的基础。

### 引入的新能力

| 能力 | 具体内容 |
|------|---------|
| 终端素养 | 文件系统导航、管道和重定向、环境变量 |
| 脚本思维 | 把重复操作变成可复用的命令 |
| CLI 设计 | 参数解析、帮助文本、错误信息——命令行的 UX |
| 包发布 | npm publish 或 pip publish——你的工具变成可安装的包 |
| 文件系统操作 | 读写文件、遍历目录、模式匹配 |
| 管道组合 | 小工具组合成大能力——Unix 哲学 |

### 高层知识

- **Unix 哲学**：每个工具做好一件事，工具之间通过管道组合。这是最优雅的软件设计哲学，也是理解 AI 代理协作的基础。
- **CLI 是最好的 UX（对某些用户而言）**：命令行界面看似"原始"，但对于重复操作、批量处理、自动化脚本，CLI 比 GUI 高效100倍。
- **包管理生态**：npm（JavaScript）和 pip（Python）是世界上最大的软件分发网络。发布一个包意味着全世界的人都能 `npm install` 你的工具。

### 你将获得

- 一个可供他人安装使用的 CLI 工具
- 终端素养——理解 AI 代理的运行环境
- Unix 哲学的直觉——小工具组合出大能力

---

## E6: 「API 集市」— API-First 产品

**你要构建的东西**：一个 API-First 的服务——不是"有个 API 的应用"，而是"API 就是产品"。例如：AI 文本处理 API、图片优化 API、汇率转换 API、或任何可以被其他开发者集成的服务。提供文档和 SDK。

**为什么需要这个项目**：主线项目都是"面向用户"的。这个项目教你构建"面向开发者"的产品。API 设计是最纯粹的架构思维——你定义的是**契约**，而非**界面**。

### 引入的新能力

| 能力 | 具体内容 |
|------|---------|
| API 设计 | RESTful 设计原则、版本管理、错误码体系 |
| API 文档 | OpenAPI/Swagger 规范、交互式文档 |
| 认证方案 | API Key、JWT、OAuth——不同场景用不同方案 |
| 速率限制 | 防止 API 被滥用——令牌桶算法的直觉理解 |
| SDK 生成 | 从 API 定义自动生成客户端库 |
| 开发者体验（DX） | API 的"UX"——好的 API 让开发者愉悦 |
| 计量计费 | 按调用次数收费——API 经济的商业模式 |

### 高层知识

- **API 是契约**：你不是在写代码，你在**定义承诺**——"如果你发送 X，我保证返回 Y"。好的 API 契约十年不变。
- **向后兼容**：一旦有人在用你的 API，你就不能随意改变它。版本管理（v1、v2）是解决方案——新功能加在新版本，旧版本继续工作。
- **开发者体验（DX）**：面向开发者的产品的"UX"。好的文档、清晰的错误信息、一致的命名、合理的默认值——这些决定了开发者是否会选择你的 API。
- **API 经济**：Stripe、Twilio、SendGrid 都是"API-First"公司。它们的产品就是 API。这是一个巨大的商业模式。

### 你将获得

- 一个可供他人集成的 API 服务
- API 设计思维——定义契约而非界面
- 开发者体验的直觉——你的用户是开发者

---

## 拓展项目推荐路径

```
完成主线 P1-P3 后，可以开始穿插拓展项目：

主线进度          可穿插的拓展项目
─────────────────────────────
P1 数字名片完成
P2 灵感捕手完成    → E1 Chrome 扩展（客户端思维）
P3 问卷星球完成    → E5 CLI 工具（终端素养）
P4 圈子完成        → E2 自动化引擎（事件驱动）
                   → E3 移动应用（移动思维）
P5 微店完成        → E6 API 集市（契约思维）
                   → E4 数据仪表板（数据思维）
P6 AI 伙伴完成     → 任意组合
P7 全栈工厂完成    → 所有拓展项目技能融合
```

---

# 第二部分：品味锻造挑战

> **品味不是天赋，是训练出来的。**
>
> 以下挑战不是"写代码"，而是"练判断力"。
> 每个挑战设计为 30-90 分钟，可以反复做。
> 目标是建立"这个感觉不对"的直觉——不需要写代码也能判断方案好坏。

---

## 挑战类别一：架构火眼金睛

> **目标**：培养"看一眼就知道架构好不好"的直觉

### 挑战 A1：餐巾纸测试

**格式**：给你一个应用描述，你在纸上画出架构图（方框+箭头），然后让 AI 也画一个，比较差异。

**练习 1**：
> "画出一个外卖应用的架构图。要包含：用户下单、商家接单、骑手配送、支付处理、通知系统。"

**评判标准（自测）**：
- [ ] 能在一张纸上画清楚吗？
- [ ] 每个方框的职责明确吗？
- [ ] 数据流方向清晰吗？
- [ ] 失败点在哪里？（支付失败？骑手离线？商家不接单？）
- [ ] 如果用户量增加100倍，哪个部分先崩？

**练习 2**：
> "画出一个在线文档协作工具的架构图（类似 Google Docs）。"

**练习 3**：
> "画出一个社交媒体内容推荐系统的架构图。"

**进阶**：画完后，用 Claude 输入："评价这个架构设计，指出三个潜在问题和三个做得好的地方。" 对比你自己的判断。

---

### 挑战 A2：过度设计猎手

**格式**：给你两个架构方案（一个简单、一个复杂），判断哪个更合适。

**场景 1：个人博客**

方案 A（简单）：
```
Next.js 静态生成 → Vercel 部署
Markdown 文件存内容 → Git 做版本管理
```

方案 B（复杂）：
```
Next.js + 微服务架构
- 文章服务（Node.js + PostgreSQL）
- 评论服务（Node.js + MongoDB）
- 搜索服务（Elasticsearch）
- 缓存层（Redis）
- 消息队列（RabbitMQ）
- Kubernetes 编排
- 监控服务（Prometheus + Grafana）
```

**问你**：哪个更合适？为什么？什么时候方案 B 才合理？

**正确答案的方向**：方案 A 对99%的个人博客来说是正确选择。方案 B 是 Medium.com 级别的系统。选择方案 B 等于"为了炸一个鸡蛋启动了核反应堆"。**如果你不确定需不需要，那你不需要。**

**场景 2：待办事项应用**

方案 A：SQLite + 单文件应用
方案 B：PostgreSQL + Redis + GraphQL + WebSocket 实时同步

**场景 3：公司内部工具（10人使用）**

方案 A：Supabase + Next.js，简单认证
方案 B：微服务 + Kafka + 自建认证系统 + 零信任网络

---

### 挑战 A3：事后诸葛亮（Postmortem 读书会）

**格式**：阅读真实的系统故障报告，分析根本原因，思考如何预防。

**必读事后分析**：

| 事故 | 核心教训 |
|------|---------|
| [Amazon S3 宕机 (2017)](https://aws.amazon.com/message/41926/) | 一个拼写错误导致大半个互联网瘫痪——你能从中学到什么？ |
| [Replit AI 删库 (2025)](https://fortune.com/2025/07/23/ai-coding-tool-replit-wiped-database-called-it-a-catastrophic-failure/) | AI 代理删除生产数据库并说谎——AI 辅助开发的风险 |
| [Tea 应用数据泄露 (2025)](https://securityboulevard.com/2025/08/the-tea-app-hack-how-a-safe-space-leaked-13000-id-photos-1-1m-messages/) | vibe coding 导致零认证——7万张照片泄露 |
| [Knight Capital 交易灾难 (2012)](https://en.wikipedia.org/wiki/Knight_Capital_Group) | 代码部署错误导致45分钟亏损4.4亿美元 |
| [Cloudflare 宕机 (2019)](https://blog.cloudflare.com/cloudflare-outage/) | 一条正则表达式让全球 CDN 崩溃 |

**每个事故分析模板**：
1. 发生了什么？（事实描述）
2. 根本原因是什么？（不是表面原因）
3. 为什么没有被预防？（系统性缺陷）
4. 如果你是架构师，你会怎么设计来预防？
5. 这对你自己的项目有什么启示？

---

## 挑战类别二：UX 品味修炼

> **目标**：培养"这个用起来不对"的直觉

### 挑战 B1：5秒测试

**格式**：看一个应用截图5秒钟，然后闭上眼回答问题。

**怎么做**：
1. 打开任何一个你没用过的应用
2. 看首页5秒钟
3. 闭上眼
4. 回答：
   - 这个应用是做什么的？
   - 我应该先做什么？
   - 主要功能在哪里？
   - 色调给你什么感觉？

**好的应用**：5秒后你能回答所有问题。
**差的应用**：5秒后你还是困惑的。

**练习**：对以下应用做5秒测试，排名从"最清晰"到"最困惑"：
- 你最常用的5个应用
- 你最近新下载的3个应用
- 竞品应用对比

### 挑战 B2：空状态审计

**格式**：检查一个应用在"没有数据"时的表现。

**为什么重要**：新用户看到的第一个画面往往是空状态——没有帖子、没有消息、没有数据。这是留住用户还是赶走用户的关键时刻。

**审计清单**：
1. 打开你的任何一个应用项目（或任何应用）
2. 检查所有空状态：
   - [ ] 新用户首次登录看到什么？
   - [ ] 搜索无结果时显示什么？
   - [ ] 列表为空时显示什么？
   - [ ] 网络断开时显示什么？
   - [ ] 加载中时显示什么？
   - [ ] 操作失败时显示什么？

**好的空状态**：
- 告诉用户为什么是空的
- 告诉用户下一步该做什么
- 提供行动按钮（"创建你的第一个 XXX"）

**差的空状态**：
- 白屏
- 只显示"No data"
- 没有任何指引

### 挑战 B3：摩擦日记

**格式**：连续一周，记录你在使用任何软件时遇到的"摩擦"。

**什么是摩擦**：
- 需要多次点击才能完成的简单操作
- 让你困惑的按钮或文字
- 让你等待的加载
- 让你烦躁的弹窗或通知
- 让你害怕点击的"不可逆操作"

**日记模板**：
```
日期：_____
应用：_____
摩擦描述：_____
我的感受：_____
我会怎么改进：_____
```

**一周后回顾**：
- 哪类摩擦出现最多？
- 你的项目中有类似的摩擦吗？
- 选3个最严重的，描述给 AI，让它帮你修复

### 挑战 B4：10个 "What If" 测试

**格式**：对你自己的（或任何一个）应用，问10个 "What if" 问题。

```
1. What if 用户名字有 100 个字符？
2. What if 用户在表单提交过程中关闭页面？
3. What if 两个用户同时编辑同一个内容？
4. What if 网络在上传文件到一半时断开？
5. What if 用户复制粘贴了一段 HTML 到输入框？
6. What if 数据库中有 100 万条记录？
7. What if 用户用的是10年前的手机？
8. What if 用户是色盲？
9. What if 用户的时区和服务器时区不同？
10. What if 用户点击了两次"提交"按钮？
```

**每个问题都测试一下**。记录结果：崩溃了？显示错误了？表现正常？

---

## 挑战类别三：安全直觉训练

> **目标**：培养"这里可能有安全问题"的嗅觉

### 挑战 C1：OWASP Juice Shop 闯关

**格式**：在一个故意设计的不安全应用上，用自然语言找到并利用漏洞。

**设置**：
```bash
# 安装 OWASP Juice Shop（故意不安全的 Web 应用，用于安全教育）
docker run -d -p 3000:3000 bkimminich/juice-shop
# 打开 http://localhost:3000
```

**入门挑战（不需要技术知识）**：
1. **找到管理员页面**：它不在导航栏里，但 URL 可以猜
2. **找到其他用户的数据**：修改 URL 中的数字，看能不能看到不属于你的东西
3. **XSS 测试**：在搜索框中输入 `<script>alert('hack')</script>`，看会发生什么
4. **SQL 注入测试**：在登录框中输入 `' OR 1=1 --`，看能不能绕过登录

**反思**：
- 这些"攻击"有多简单？
- 你自己的项目有这些问题吗？
- 你能用 AI 检查你的代码有没有这些漏洞吗？

### 挑战 C2：AI 生成代码安全审计

**格式**：让 AI 生成一段代码，然后让另一个 AI 审计它的安全性。

**实战流程**：
```
步骤 1：对 AI A 说
"用 Node.js + Express 写一个用户注册和登录 API，
包含密码存储和 JWT 认证。"

步骤 2：拿到代码后，对 AI B 说
"你是安全审计专家。审查以下代码，
找出所有安全漏洞，按严重程度排序：
[粘贴代码]"

步骤 3：记录发现
- AI A 引入了多少安全问题？
- 这些问题你能自己发现吗？
- AI B 的审计可靠吗？（它有没有漏掉问题？有没有误报？）
```

**常见发现预期**：
- 密码没有加盐哈希
- JWT 密钥硬编码
- 没有速率限制（可以暴力破解密码）
- 没有输入验证
- 错误信息泄露过多信息（"用户名不存在" vs "用户名或密码错误"）

### 挑战 C3：隐私思维训练

**格式**：分析你的应用收集了哪些数据，思考"如果这些数据泄露了会怎样"。

**数据审计清单**：
```
我的应用收集了什么？
- [ ] 邮箱地址
- [ ] 密码（如何存储的？明文？哈希？加盐哈希？）
- [ ] 姓名
- [ ] 位置信息
- [ ] 浏览历史
- [ ] 搜索记录
- [ ] 文件上传
- [ ] 支付信息

如果这些数据全部泄露：
- 用户会受到什么伤害？
- 我需要通知谁？（GDPR 要求 72 小时内通知）
- 我有哪些数据是其实不需要收集的？

最小化原则：
- 能不收集就不收集
- 能不存储就不存储
- 能加密就加密
- 能到期删除就到期删除
```

---

## 挑战类别四：提示工程对决

> **目标**：培养"好提示 vs 差提示"的判断力

### 挑战 D1：提示改造

**格式**：给你一个差的提示，你改写成好的提示。然后两个提示都送给 AI，比较输出质量。

**题目 1**：
```
差的提示："帮我做一个网站"

你的改造：______
```

**参考答案方向**：
```
好的提示：
"创建一个独立咖啡店的官网。要求：
- 首页展示咖啡店照片、营业时间、地址（带地图）
- 菜单页面，分类显示（咖啡/茶/甜点），每项有价格和描述
- 关于我们页面，讲述品牌故事
- 联系页面，带联系表单（姓名、邮箱、消息）

技术要求：Next.js + Tailwind CSS
风格：温暖木质色调，Serif 字体标题，Sans-serif 正文
响应式：手机优先设计
部署到 Vercel
表单使用 Formspree 处理"
```

**题目 2**：
```
差的提示："加个数据库"
你的改造：______
```

**题目 3**：
```
差的提示："登录不工作了，修一下"
你的改造：______
```

**题目 4**：
```
差的提示："性能太慢"
你的改造：______
```

**题目 5**：
```
差的提示："加个 AI 功能"
你的改造：______
```

### 挑战 D2：规格说明 vs 愿望清单

**格式**：将模糊的产品愿望转化为可执行的规格说明。

**练习**：把以下"愿望"转化为 SPEC.md 格式的规格说明。

**愿望 1**："做一个社交应用让人们分享读书笔记"

你需要定义：
- 用户角色有哪些？（读者、作者？管理员？）
- 核心功能是什么？（每个功能限3句话描述）
- 数据模型是什么？（用户、书籍、笔记、评论 的关系）
- 安全要求是什么？（谁能看到什么？）
- 边界是什么？（笔记最长多少字？图片多大？）
- 第一版不做什么？（明确排除的功能）

**愿望 2**："做一个项目管理工具"
**愿望 3**："做一个 AI 写作助手"

### 挑战 D3：上下文工程挑战

**格式**：为同一个项目写三个版本的 CLAUDE.md，测试哪个版本让 AI 产出最好。

**版本 A**：最小版本（5行以内）
**版本 B**：详细版本（50行左右）
**版本 C**：过度详细版本（200行以上）

**测试方法**：
1. 用每个版本的 CLAUDE.md 启动一个新 Claude Code 会话
2. 给同样的任务："给这个项目添加用户个人资料页面"
3. 比较三次输出的质量

**你会发现**：
- 版本 A 产出的代码风格可能和项目不一致
- 版本 B 通常产出最好的结果
- 版本 C 反而可能变差（AI 被过多指令淹没）

**核心教训**：上下文管理有个"最佳区间"——太少不够，太多有害。

---

## 挑战类别五：成本与权衡思维

> **目标**：培养"这个方案要花多少钱"的直觉

### 挑战 E1：成本估算沙盘

**格式**：给定一个应用场景，估算运营成本。

**场景 1：AI 客服机器人**
```
- 每天 1000 个客户对话
- 每次对话平均 8 轮
- 每轮约 500 输入 token + 300 输出 token
- 使用 Claude Sonnet

估算：
- 每日 token 消耗 = ?
- 每月 API 费用 = ?
- 如果客户量增长10倍呢？
- 有什么方法降低成本？（缓存常见问答？用更便宜的模型处理简单问题？）
```

**场景 2：图片分享社区**
```
- 10,000 月活用户
- 每人每月上传 20 张图片（平均 3MB/张）
- 每张图片生成 3 种尺寸（缩略图、中、原图）

估算：
- 每月存储增长 = ?
- 每月带宽消耗 = ?（假设每张图平均被查看 50 次）
- 1 年后的存储成本 = ?
- CDN 费用 = ?
```

**场景 3：实时协作文档**
```
- 500 个团队，每团队 10 人
- 每人每天活跃 4 小时
- WebSocket 长连接
- 每秒约 2 次同步操作

估算：
- 同时在线连接数 = ?
- 每月 WebSocket 流量 = ?
- 数据库写入 QPS = ?
- 需要什么级别的服务器？
```

### 挑战 E2：方案权衡辩论

**格式**：对同一个问题提出两个方案，论证各自的优缺点，做出选择。

**辩题 1：自建 vs 购买**
> 你需要给你的应用加搜索功能。
> 方案 A：使用 Algolia（搜索即服务，每月 $29 起）
> 方案 B：自建搜索（PostgreSQL 全文检索，免费但需要开发）

需要考虑：
- 现在的用户量需要什么级别？
- 开发时间值多少钱？
- 如果将来要迁移呢？
- 哪些功能是你现在不需要的？

**辩题 2：单体 vs 微服务**
> 你要构建一个电商平台。
> 方案 A：单体应用（一个大应用，所有功能在一起）
> 方案 B：微服务（商品服务、订单服务、支付服务、用户服务分开）

**辩题 3：Serverless vs 服务器**
> 你要构建一个 API，预计每天 50,000 请求。
> 方案 A：Vercel Serverless Functions
> 方案 B：Railway 上运行 Express 服务器

### 挑战 E3：技术选型答辩

**格式**：为一个新项目选择技术栈，并准备回答"为什么"。

**练习**：
你要构建一个"宠物领养平台"。需要选择：
1. 前端框架：Next.js vs Remix vs Astro
2. 数据库：Supabase vs Firebase vs PlanetScale
3. 认证：Clerk vs Supabase Auth vs Auth.js
4. 部署：Vercel vs Railway vs Render
5. 样式：Tailwind vs CSS Modules vs styled-components

**对每个选择，回答**：
- 你选了什么？
- 为什么选这个而不是其他？
- 这个选择的最大风险是什么？
- 什么情况下你会改变这个选择？

**然后让 AI 挑战你的选择**：
```
"我为一个宠物领养平台选择了以下技术栈：[你的选择]
请扮演一个持反对意见的资深工程师，挑战我的每个选择。
告诉我可能遇到的问题和替代方案。"
```

---

## 挑战类别六：代码审查能力（不用写代码）

> **目标**：培养"看出问题"的能力——不需要懂语法

### 挑战 F1：AI 对 AI 审查

**格式**：让一个 AI 写代码，让另一个 AI 审查，你来评判谁说的对。

**流程**：
```
1. 对 AI A 说："用 TypeScript 写一个用户注册函数，
   包含邮箱验证、密码强度检查、和数据库存储。"

2. 对 AI B 说："审查以下代码，找出所有问题：
   [粘贴 AI A 的代码]
   分类为：安全问题、性能问题、可维护性问题、逻辑错误。"

3. 你来判断：
   - AI B 找到的问题是真的吗？
   - AI B 有没有漏掉什么？
   - AI B 有没有"过度审查"（挑出不是问题的问题）？
```

**目标**：不是你能读懂代码，而是你能判断**建议的合理性**。
- "建议使用参数化查询防止 SQL 注入" → 合理（你知道什么是 SQL 注入）
- "变量名应该用驼峰命名" → 可能合理，但不是关键问题
- "建议用 CQRS 模式重写" → 可能过度设计

### 挑战 F2：代码"味道"识别

**格式**：学习识别"代码味道"——不需要读懂代码，只需要看到模式。

**味道 1：巨大的文件**
```
如果一个文件超过 500 行 → 可能做了太多事情
问 AI："这个文件的职责是什么？它应该被拆分成几个文件？"
```

**味道 2：大量重复**
```
如果看到相似的代码块出现 3 次以上 → 应该提取为公用函数
问 AI："这段代码有重复吗？如何消除重复？"
```

**味道 3：深层嵌套**
```
如果看到 4 层以上的缩进 → 逻辑可能太复杂
  if {
    if {
      if {
        if {  ← 这里已经太深了
问 AI："如何简化这个嵌套结构？"
```

**味道 4：魔法数字**
```
如果看到代码中有 86400、3.14159、1024 等数字直接写在代码里
→ 应该定义为有名字的常量
"MAX_FILE_SIZE = 1024" 比 "if (size > 1024)" 好
```

**味道 5：注释解释"做了什么"而不是"为什么"**
```
// 差的注释
x = x + 1  // x 加 1 ← 这谁都看得出来

// 好的注释
x = x + 1  // 补偿时区偏移 ← 这解释了为什么
```

### 挑战 F3：重构前后对比

**格式**：看重构前后的代码，判断重构是否改进了代码。

**怎么做**：
```
对 AI 说：
"给我看一个代码重构的例子。
展示重构前和重构后的代码，
并解释为什么重构后更好。
使用简单的 JavaScript，不要太复杂。"

然后问自己：
- 重构后确实更简洁了吗？
- 重构有没有改变行为？（重构不应该改变功能）
- 重构是否引入了新的复杂性？
- 如果你是"老板"，你会批准这次重构吗？
```

---

## 品味培养的每日习惯

### 5 分钟品味晨练

每天早上打开一个你常用的应用，花5分钟做以下练习之一（轮流）：

| 周一 | 周二 | 周三 | 周四 | 周五 |
|------|------|------|------|------|
| 5秒测试：截图新应用首页 | 空状态审计：找3个空状态 | 摩擦日记：记1个摩擦点 | What if 测试：问3个问题 | AI 代码审查：让 AI 审查一段代码 |

### 周末深度练习（选一个）

- 读一篇事故 Postmortem
- 做一个架构餐巾纸测试
- 做一次提示改造练习
- 做一次成本估算沙盘
- OWASP Juice Shop 闯两关

---

## 品味成长里程碑

### Level 1：观察者（完成10个挑战后）
- 能识别"这个不对"但说不清楚为什么
- 能做5秒测试并给出基本判断
- 知道什么是过度设计但不确定边界在哪

### Level 2：评论家（完成25个挑战后）
- 能清晰说出"这里有什么问题"
- 能区分关键问题和次要问题
- 能在 AI 的建议中分辨好坏
- 能写出比之前好3倍的提示

### Level 3：品鉴师（完成全部挑战后）
- "这个感觉不对"已经变成了直觉
- 能在30秒内判断一个架构是否过度设计
- 能预测"这个方案将来会在哪里出问题"
- 能写出让 AI 产出生产级代码的规格说明
- 开始有自己的"风格"——对什么是好软件有自己的主张

---

## 核心理念

> **品味的本质是：见过足够多的好与坏，建立了模式匹配的直觉。**
>
> 你不需要写代码就能培养品味。
> 你需要的是：大量观察 + 刻意练习 + 反馈循环。
>
> 厨师不需要自己种菜来判断食材好坏。
> 建筑师不需要自己搬砖来判断结构是否安全。
> **你不需要自己写代码来判断软件方案的好坏。**

---

*扩展课程设计日期：2026年2月16日*
*基于补充调研覆盖：移动开发、自动化、浏览器扩展、数据分析、CLI工具、API设计、安全训练、UX品鉴、成本分析*
